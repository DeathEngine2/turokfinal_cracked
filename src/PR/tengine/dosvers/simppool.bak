// simppool.cpp
//

#include "stdafx.h"
#include "simppool.h"
#include "tengine.h"
#include "scaling.h"
#include "scene.h"

#include "debug.h"

// don't know max radius so use large number
#define DYNAMIC_SIMPLE_MAXRADIUS	(400*SCALING_FACTOR)


/////////////////////////////////////////////////////////////////////////////

// globals
CEnemyAttributes	dynamic_simple_attributes;
CCollisionInfo		ci_dynamic_simple;
CCollisionInfo		ci_bouncy;

// Key pickups (generated by longhunter and mantis levels)
CEnemyAttributes	pickup_key_level5b_attributes ;
CEnemyAttributes	pickup_key_level8c_attributes ;




// CSimplePool implementation
/////////////////////////////////////////////////////////////////////////////

CDynamicSimple*		CSimplePool__AllocateSimpleInstance(CSimplePool *pThis);
void						CSimplePool__DeallocateSimpleInstance(CSimplePool *pThis, CDynamicSimple *pDyn);

#define					CScene__AddCollisionInstance(pThis, pInst) if (pThis->m_nInstances != COLLISION_MAX_INSTANCES) pThis->m_pInstances[pThis->m_nInstances++] = pInst;

/////////////////////////////////////////////////////////////////////////////
// CSimplePool

void CSimplePool__Construct(CSimplePool *pThis)
{
	int	i;

	TRACE0("CSimplePool construction\r\n");

	ASSERT(SIMPLES_MAX_COUNT >= 1);

	pThis->m_pFreeHead = &pThis->m_Simples[0];
	pThis->m_pActiveHead = pThis->m_pActiveTail = NULL;

	pThis->m_pCache = NULL;
	pThis->m_pceObjectsIndex = NULL;
	pThis->m_rpObjectsAddress = NULL;
	
	for (i=0; i<(SIMPLES_MAX_COUNT-1); i++)
		pThis->m_Simples[i].m_pNext = &pThis->m_Simples[i+1];

	pThis->m_Simples[SIMPLES_MAX_COUNT-1].m_pNext = NULL;

	CCollisionInfo__SetPickupDefaults(&ci_dynamic_simple);
	CCollisionInfo__SetPickupDefaults(&ci_bouncy);

	// Setup default attributes
	CEnemyAttributes__SetDefaults(&dynamic_simple_attributes);
	dynamic_simple_attributes.m_dwTypeFlags     |= AI_TYPE_COLLISION;
	dynamic_simple_attributes.m_dwTypeFlags     |= AI_TYPE_TRACKGROUND;
	dynamic_simple_attributes.m_CollisionRadius  = 3*SCALING_FACTOR;

	// Setup longhunter key pickup attributes
	memcpy(&pickup_key_level5b_attributes, &dynamic_simple_attributes, sizeof(CEnemyAttributes)) ;
	pickup_key_level5b_attributes.m_Id = 1 ;

	// Setup mantis key pickup attributes
	memcpy(&pickup_key_level8c_attributes, &dynamic_simple_attributes, sizeof(CEnemyAttributes)) ;
	pickup_key_level8c_attributes.m_Id = 2 ;

	// Initialize
	for (i=0; i<SIMPLES_MAX_COUNT; i++)
		CDynamicSimple__Construct(&pThis->m_Simples[i]);

	pThis->m_Initialized = FALSE;
}

CDynamicSimple* CSimplePool__AllocateSimpleInstance(CSimplePool *pThis)
{
	CDynamicSimple	*pDyn;

	if (!pThis->m_pFreeHead)
	{
		ASSERT(pThis->m_pActiveTail);

#ifdef TRACE_MEM
	TRACE("CDynamicSimple: Stealing oldest instance: %x.\r\n", pThis->m_pActiveTail);
#endif

		CSimplePool__DeallocateSimpleInstance(pThis, pThis->m_pActiveTail);
	}

	ASSERT(pThis->m_pFreeHead);

	// get first node in free list
	pDyn = pThis->m_pFreeHead;

	// remove from free list
	pThis->m_pFreeHead = pDyn->m_pNext;

	// add to head of active list
	if (pThis->m_pActiveHead)
		pThis->m_pActiveHead->m_pLast = pDyn;
	pDyn->m_pNext = pThis->m_pActiveHead;
	pThis->m_pActiveHead = pDyn;
	pDyn->m_pLast = NULL;
	
	// update tail of active list
	if (!pThis->m_pActiveTail)
		pThis->m_pActiveTail = pDyn;

#ifdef TRACE_MEM
	TRACE("CSimplePool: Allocated instance: %x.\r\n", pDyn);
#endif

	ASSERT(!CDynamicSimple__IsAllocated(pDyn));
	CDynamicSimple__SetAllocated(pDyn);

	// Set life time to infinite
	pDyn->m_LifeTime = 0 ;

	// Init monitor ptr flag
	pDyn->m_ppPickup = NULL ;

	return pDyn;
}


void CSimplePool__DeallocateSimpleInstance(CSimplePool *pThis, CDynamicSimple *pDyn)
{
	ASSERT(pDyn);

	ASSERT(CDynamicSimple__IsAllocated(pDyn));
	if (!CDynamicSimple__IsAllocated(pDyn))
		return;

	CDynamicSimple__SetNotAllocated(pDyn);

	// If there is one, clear the monitor flag
	if (pDyn->m_ppPickup)
		*pDyn->m_ppPickup = NULL ;

	// remove from active list
	if (pDyn->m_pLast)
		pDyn->m_pLast->m_pNext = pDyn->m_pNext;
	if (pDyn->m_pNext)
		pDyn->m_pNext->m_pLast = pDyn->m_pLast;

	// update head of active list
	if (pThis->m_pActiveHead == pDyn)
		pThis->m_pActiveHead = pDyn->m_pNext;

	// update tail of active list
	if (pThis->m_pActiveTail == pDyn)
		pThis->m_pActiveTail = pDyn->m_pLast;

	// add to free list
	pDyn->m_pNext = pThis->m_pFreeHead;
	pThis->m_pFreeHead = pDyn;

#ifdef TRACE_MEM
	TRACE("CSimplePool: Deallocated simple instance: %x.\r\n", pDyn);
#endif
}

CDynamicSimple* CSimplePool__CreateSimpleInstance(CSimplePool *pThis, int nType,
																  CVector3 vVelocity,
																  CVector3 vPos, CGameRegion *pRegion, FLOAT Time)
{
	int					nObjType;
	CIndexedSet			isObjectsIndex;
	ROMAddress			*rpObjectAddress;
	CDynamicSimple		*pDyn;

	if (!pThis->m_Initialized)
		return NULL ;
	
	nObjType = CScene__LookupObjectType(&GetApp()->m_Scene, nType);
	if (nObjType == -1)
		return NULL ;

	pDyn = CSimplePool__AllocateSimpleInstance(pThis);
	ASSERT(pDyn);

	ASSERT(pThis->m_pceObjectsIndex);
	CIndexedSet__ConstructFromRawData(&isObjectsIndex,
												 CCacheEntry__GetData(pThis->m_pceObjectsIndex),
												 FALSE);

	// find object address
	ASSERT(pThis->m_rpObjectsAddress);
	rpObjectAddress = CIndexedSet__GetROMAddress(&isObjectsIndex,
																pThis->m_rpObjectsAddress,
																nObjType);

	// Set ptr to attributes (longhunter and mantis create key pickups)
	switch(nType)
	{
		case AI_OBJECT_PICKUP_KEY5:
			pDyn->s.ah.ih.m_pEA = &pickup_key_level5b_attributes;
			break ;

		case AI_OBJECT_PICKUP_KEY8:
			pDyn->s.ah.ih.m_pEA = &pickup_key_level8c_attributes;
			break ;

		default:
			pDyn->s.ah.ih.m_pEA = &dynamic_simple_attributes;
	}


	pDyn->s.ah.ih.m_nObjType = nObjType;

	pDyn->s.ah.ih.m_vPos = vPos;
	//CQuatern__Identity(&pDyn->s.m_qRot);
	//pDyn->s.m_RotY = 0;
	pDyn->s.m_RotAngle = 0;
	pDyn->s.m_AngleVel = 0;
	pDyn->s.vRotAxis.x = 0 ;
	pDyn->s.vRotAxis.y = 1 ;
	pDyn->s.vRotAxis.z = 0 ;

	pDyn->s.m_Bounds.m_vMin.x = vPos.x - DYNAMIC_SIMPLE_MAXRADIUS;
	pDyn->s.m_Bounds.m_vMin.y = vPos.y - DYNAMIC_SIMPLE_MAXRADIUS;
	pDyn->s.m_Bounds.m_vMin.z = vPos.z - DYNAMIC_SIMPLE_MAXRADIUS;
	pDyn->s.m_Bounds.m_vMax.x = vPos.x + DYNAMIC_SIMPLE_MAXRADIUS;
	pDyn->s.m_Bounds.m_vMax.y = vPos.y + DYNAMIC_SIMPLE_MAXRADIUS;
	pDyn->s.m_Bounds.m_vMax.z = vPos.z + DYNAMIC_SIMPLE_MAXRADIUS;

	pDyn->s.m_rpObjectIndexAddress = rpObjectAddress;

	pDyn->s.ah.ih.m_pCurrentRegion = pRegion;

	pDyn->s.m_Scale = 0;
	pDyn->s.m_wFlags = SIMPLE_FLAG_VISIBLE | SIMPLE_FLAG_DYNAMIC | SIMPLE_FLAG_SCALEUP;
	pDyn->s.ah.m_vVelocity = vVelocity;

	CIndexedSet__Destruct(&isObjectsIndex);

	return pDyn ;
}

void CSimplePool__Advance(CSimplePool *pThis)
{
	CDynamicSimple	*pDyn, *pCurrent;

	ASSERT(pThis->m_pCache);

	pDyn = pThis->m_pActiveHead;
	while (pDyn)
	{
		pCurrent = pDyn;
		pDyn = pDyn->m_pNext;

		CDynamicSimple__Advance(pCurrent);
	}
}

void CSimplePool__AddToCollisionList(CSimplePool *pThis, struct CScene_t *pScene)
{
	CDynamicSimple	*pDyn;

	ASSERT(pThis->m_pCache);

	pDyn = pThis->m_pActiveHead;
	while (pDyn)
	{
		if (		!(pDyn->s.m_wFlags & SIMPLE_FLAG_GONE)
				&& (pDyn->s.m_wFlags & SIMPLE_FLAG_VISIBLE)
				&& (pDyn->s.ah.ih.m_pEA->m_dwTypeFlags & AI_TYPE_COLLISION) )
		{
			if (CBoundsRect__IsOverlappingBounds(&anim_bounds_rect, &pDyn->s.m_Bounds))
				CScene__AddCollisionInstance(pScene, &pDyn->s.ah.ih);
		}

		pDyn = pDyn->m_pNext;
	}
}

void CSimplePool__Draw(CSimplePool *pThis, Gfx **ppDLP, CCacheEntry *pceTextureSetsIndex)
{
	CDynamicSimple	*pDyn;

	ASSERT(pThis->m_pCache);

	pDyn = pThis->m_pActiveHead;
	while (pDyn)
	{
		// Fade the puppies out, sexy style. 0 = max trans, 255 = min trans
		if ((pDyn->m_LifeTime > 0) && (pDyn->m_LifeTime <= SECONDS_TO_FRAMES(0.5)))
		{
			fx_mode = FXMODE_TOTRANSPARENT ;
			fx_color[3] = (255.0 * pDyn->m_LifeTime) / SECONDS_TO_FRAMES(0.5) ;
		}

		// Draw the pickup
		CGameSimpleInstance__Draw(&pDyn->s, ppDLP, pThis->m_pCache, pceTextureSetsIndex);

		// Set draw mode back to normal
		fx_mode = FXMODE_NONE ;

		pDyn = pDyn->m_pNext;
	}
}

void CSimplePool__Initialize(CSimplePool *pThis, CCartCache *pCache,
									  CCacheEntry *pceObjectsIndex, ROMAddress *rpObjectsAddress)
{
	pThis->m_pCache = pCache;
	pThis->m_pceObjectsIndex = pceObjectsIndex;
	pThis->m_rpObjectsAddress = rpObjectsAddress;
	pThis->m_Initialized = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDynamicSimple

void CDynamicSimple__Construct(CDynamicSimple *pThis)
{
	pThis->s.ah.ih.m_CollisionHeightOffset = 0;
	pThis->s.ah.ih.m_pEA = &dynamic_simple_attributes;
	pThis->s.ah.ih.m_Type = I_SIMPLE;
	pThis->m_dwFlags = 0 ;
}


void CDynamicSimple__Advance(CDynamicSimple *pThis)
{
	CCollisionInfo	*pCI;
	BOOL	Delete = FALSE ;
	CQuatern			qRot;
	CMtxF				mfRot ;
	CVector3			vVelocity ;

	CVector3			vN, vV, vAxis ;
	BOOL				check ;
	int				nType ;
	float				r ;

	// Life time ran out? (0 = infinite)
	if (pThis->m_LifeTime > 0)
	{
		pThis->m_LifeTime -= frame_increment ;
		if (pThis->m_LifeTime <= 0)
			Delete = TRUE ;
	}

	// Update or delete?
	if ((!Delete) && (CBoundsRect__IsOverlappingBounds(&anim_bounds_rect, &pThis->s.m_Bounds)))
	{
		if (AI_IsBouncy(CInstanceHdr__TypeFlag(&pThis->s.ah.ih)))
			pCI = &ci_bouncy ;
		else
			pCI = &ci_dynamic_simple ;

		// No movement on keys
		if (pThis->s.ah.ih.m_pEA != &dynamic_simple_attributes)
		{
			CVector3__Set(&pThis->s.ah.m_vVelocity,0,0,0) ;
		}

		// Preform collision
		CAnimInstanceHdr__Collision(&pThis->s.ah, &pThis->s.ah.ih.m_pCurrentRegion,
										 &pThis->s.ah.ih.m_vPos, pThis->s.ah.ih.m_vPos,
										 pCI, FALSE, TRUE, TRUE, TRUE);

		// Longhunter key should be above key holder which is part of elevator geom!
		if (CInstanceHdr__TypeFlag(&pThis->s.ah.ih) == AI_OBJECT_PICKUP_KEY5)
		{
			pThis->s.ah.ih.m_vPos.y = (1.0*SCALING_FACTOR) + 
				CGameRegion__GetGroundHeight(pThis->s.ah.ih.m_pCurrentRegion,
													  pThis->s.ah.ih.m_vPos.x,
													  pThis->s.ah.ih.m_vPos.z) ;
		}

		// make bouncy stuff spin (& bounce)
		if (AI_IsBouncy(CInstanceHdr__TypeFlag(&pThis->s.ah.ih)))
		{

			// add some blood particles to bodyparts
				// NOTE:
				// this spinning blood only works if the
				// particle type has ADD SOURCE VELOCITY checked
			nType = CInstanceHdr__TypeFlag(&pThis->s.ah.ih) ;
			switch (nType)
			{
				case AI_OBJECT_BOUNCY_ALIEN_TORSO:
				case AI_OBJECT_BOUNCY_ALIEN_HEAD:
					if (CVector3__MagnitudeSquared(&pThis->s.ah.m_vVelocity) > 100)
					{
						CMtxF__Rotate(mfRot, pThis->s.m_RotAngle, pThis->s.vRotAxis.x, pThis->s.vRotAxis.y, pThis->s.vRotAxis.z);
						CMtxF__VectorMult(mfRot, &pThis->s.ah.m_vVelocity, &vVelocity) ;
						CVector3__MultScaler(&vVelocity, &vVelocity, .5);

						CQuatern__Identity(&qRot);
						CParticleSystem__CreateParticle(&GetApp()->m_Scene.m_ParticleSystem,
																  &pThis->s.ah.ih,
																  PARTICLE_TYPE_GENERIC253,
																  vVelocity,
																  qRot,
																  pThis->s.ah.ih.m_vPos,
																  pThis->s.ah.ih.m_pCurrentRegion,
																  PARTICLE_NOEDGE, TRUE);
					}
					break ;

				case AI_OBJECT_BOUNCY_LEAPER_TORSO:
				case AI_OBJECT_BOUNCY_LEAPER_HEAD:
					if (CVector3__MagnitudeSquared(&pThis->s.ah.m_vVelocity) > 100)
					{
						CMtxF__Rotate(mfRot, pThis->s.m_RotAngle, pThis->s.vRotAxis.x, pThis->s.vRotAxis.y, pThis->s.vRotAxis.z);
						CMtxF__VectorMult(mfRot, &pThis->s.ah.m_vVelocity, &vVelocity) ;
						CVector3__MultScaler(&vVelocity, &vVelocity, .5);

						CQuatern__Identity(&qRot);
						CParticleSystem__CreateParticle(&GetApp()->m_Scene.m_ParticleSystem,
																  &pThis->s.ah.ih,
																  PARTICLE_TYPE_GUSH_BLOOD,
																  vVelocity,
																  qRot,
																  pThis->s.ah.ih.m_vPos,
																  pThis->s.ah.ih.m_pCurrentRegion,
																  PARTICLE_NOEDGE, TRUE);
					}
					break ;
			}


			check = FALSE ;
			if (pCI->m_GroundCollision)
			{
				AI_DoSound((CInstanceHdr *)pThis, 445, 1, 0);
				vN = CGameRegion__GetGroundUnitNormal(pCI->m_pGroundCollisionRegion) ;
				check = TRUE ;
			}
			else if (pCI->m_WallCollision)
			{
				AI_DoSound((CInstanceHdr *)pThis, 445, 1, 0);
				vN = CGameRegion__GetGroundUnitNormal(pCI->m_pWallCollisionRegion) ;
				check = TRUE ;
			}
			else if (CInstanceHdr__IsOnGround(&pThis->s.ah.ih))
			{
				vN = CGameRegion__GetGroundUnitNormal(pThis->s.ah.ih.m_pCurrentRegion) ;
				check = TRUE ;
			}

			if (check)
			{
				// randomize bounce vector
				//pThis->s.ah.m_vVelocity = CVector3__RandomizeDirectionX(&pThis->s.ah.m_vVelocity, 0.2);
				//pThis->s.ah.m_vVelocity = CVector3__RandomizeDirectionZ(&pThis->s.ah.m_vVelocity, 0.2);

				r = 40 ;
				// make bloody bits spin slower
				if ((nType == AI_OBJECT_BOUNCY_ALIEN_HEAD) ||
					 (nType == AI_OBJECT_BOUNCY_ALIEN_TORSO) ||
					 (nType == AI_OBJECT_BOUNCY_LEAPER_HEAD) ||
					 (nType == AI_OBJECT_BOUNCY_LEAPER_TORSO))
					 r = 100 ;

				vV = pThis->s.ah.m_vVelocity ;
				CVector3__Normalize(&vV) ;
				CVector3__Cross(&vAxis, &vN, &vV) ;
				CVector3__Normalize(&vAxis) ;
				pThis->s.m_AngleVel = (CVector3__Magnitude(&pThis->s.ah.m_vVelocity) / r) ;
				pThis->s.vRotAxis = vAxis ;
			}
			pThis->s.m_RotAngle += pThis->s.m_AngleVel * frame_increment ;
		}

		pThis->s.m_Bounds.m_vMin.x = pThis->s.ah.ih.m_vPos.x - DYNAMIC_SIMPLE_MAXRADIUS;
		pThis->s.m_Bounds.m_vMin.y = pThis->s.ah.ih.m_vPos.y - DYNAMIC_SIMPLE_MAXRADIUS;
		pThis->s.m_Bounds.m_vMin.z = pThis->s.ah.ih.m_vPos.z - DYNAMIC_SIMPLE_MAXRADIUS;
		pThis->s.m_Bounds.m_vMax.x = pThis->s.ah.ih.m_vPos.x + DYNAMIC_SIMPLE_MAXRADIUS;
		pThis->s.m_Bounds.m_vMax.y = pThis->s.ah.ih.m_vPos.y + DYNAMIC_SIMPLE_MAXRADIUS;
		pThis->s.m_Bounds.m_vMax.z = pThis->s.ah.ih.m_vPos.z + DYNAMIC_SIMPLE_MAXRADIUS;
	}
	else if (pThis->s.ah.ih.m_pEA == &dynamic_simple_attributes)  // Don't delete key's!!!
	{
		CDynamicSimple__Delete(pThis);
	}
}

void CDynamicSimple__Delete(CDynamicSimple *pThis)
{
	CSimplePool		*pPool;

	pPool = &GetApp()->m_Scene.m_SimplePool;
	CSimplePool__DeallocateSimpleInstance(pPool, pThis);
}
