// graphu64.c

#include "stdafx.h"
#include "cppu64.h"
#include "graphu64.h"
#include "tengine.h"
#include "attract.h"

// global utility values
/////////////////////////////////////////////////////////////////////////////
float		sin_angle,
			inv_mag_squared;

DWORD		random_value;
DWORD		sound_random_value;

// CMtxF implementation
/////////////////////////////////////////////////////////////////////////////
// matrix routines optimized and unrolled by Carl and Steve


// CMtxF
/////////////////////////////////////////////////////////////////////////////
#define MATRIX_OPTIMISE	1		// Unroll loops, calls to CMtxF__Identity etc.



/////////////////////////////////////////////////////////////////////////////
//	CMtxF__PostMult
/////////////////////////////////////////////////////////////////////////////
#if 0

#if MATRIX_OPTIMISE
#define	MATRIX_K_LOOP(i,j)					\
 	value = mfLeft[i][0] * mfRight[0][j] + \
			  mfLeft[i][1] * mfRight[1][j] + \
			  mfLeft[i][2] * mfRight[2][j] + \
			  mfLeft[i][3] * mfRight[3][j] ; \
	mfThis[i][j] = value ;

//#define	MATRIX_K_LOOP(i,j)						\
//	value = mfLeft[i][0] * mfRight[0][j] ;		\
//   value += mfLeft[i][1] * mfRight[1][j] ;	\
//   value += mfLeft[i][2] * mfRight[2][j] ;	\
//   value += mfLeft[i][3] * mfRight[3][j] ;	\
//	mfThis[i][j] = value ;

#define	MATRIX_J_LOOP(i)	\
	MATRIX_K_LOOP(i,0) ;		\
	MATRIX_K_LOOP(i,1) ;		\
	MATRIX_K_LOOP(i,2) ;		\
	MATRIX_K_LOOP(i,3) ;

void CMtxF__PostMult(CMtxF mfThis, CMtxF mfLeft, CMtxF mfRight)
{
	register	float		value ;
	MATRIX_J_LOOP(0) ;
	MATRIX_J_LOOP(1) ;
	MATRIX_J_LOOP(2) ;
	MATRIX_J_LOOP(3) ;
}
#else
void CMtxF__PostMult(CMtxF mfThis, CMtxF mfLeft, CMtxF mfRight)
{
	int 		i, j, k;
	float		value;

	for (i=0; i<4; i++)
	{
   	for (j=0; j<4; j++)
		{
      	value = 0;

			for (k=0; k<4; k++)
         	value += mfLeft[i][k] * mfRight[k][j];

			mfThis[i][j] = value;
		}
	}
}
#endif

#endif



void CMtxF__PostMult4x4(CMtxF mfThis, CMtxF mfLeft, CMtxF mfRight)
{
	mfThis[0][0] = (mfLeft[0][0] * mfRight[0][0]) + (mfLeft[0][1] * mfRight[1][0]) + (mfLeft[0][2] * mfRight[2][0]) + (mfLeft[0][3] * mfRight[3][0]) ;
	mfThis[0][1] = (mfLeft[0][0] * mfRight[0][1]) + (mfLeft[0][1] * mfRight[1][1]) + (mfLeft[0][2] * mfRight[2][1]) + (mfLeft[0][3] * mfRight[3][1]) ;
	mfThis[0][2] = (mfLeft[0][0] * mfRight[0][2]) + (mfLeft[0][1] * mfRight[1][2]) + (mfLeft[0][2] * mfRight[2][2]) + (mfLeft[0][3] * mfRight[3][2]) ;
	mfThis[0][3] = (mfLeft[0][0] * mfRight[0][3]) + (mfLeft[0][1] * mfRight[1][3]) + (mfLeft[0][2] * mfRight[2][3]) + (mfLeft[0][3] * mfRight[3][3]) ;
	mfThis[1][0] = (mfLeft[1][0] * mfRight[0][0]) + (mfLeft[1][1] * mfRight[1][0]) + (mfLeft[1][2] * mfRight[2][0]) + (mfLeft[1][3] * mfRight[3][0]) ;
	mfThis[1][1] = (mfLeft[1][0] * mfRight[0][1]) + (mfLeft[1][1] * mfRight[1][1]) + (mfLeft[1][2] * mfRight[2][1]) + (mfLeft[1][3] * mfRight[3][1]) ;
	mfThis[1][2] = (mfLeft[1][0] * mfRight[0][2]) + (mfLeft[1][1] * mfRight[1][2]) + (mfLeft[1][2] * mfRight[2][2]) + (mfLeft[1][3] * mfRight[3][2]) ;
	mfThis[1][3] = (mfLeft[1][0] * mfRight[0][3]) + (mfLeft[1][1] * mfRight[1][3]) + (mfLeft[1][2] * mfRight[2][3]) + (mfLeft[1][3] * mfRight[3][3]) ;
	mfThis[2][0] = (mfLeft[2][0] * mfRight[0][0]) + (mfLeft[2][1] * mfRight[1][0]) + (mfLeft[2][2] * mfRight[2][0]) + (mfLeft[2][3] * mfRight[3][0]) ;
	mfThis[2][1] = (mfLeft[2][0] * mfRight[0][1]) + (mfLeft[2][1] * mfRight[1][1]) + (mfLeft[2][2] * mfRight[2][1]) + (mfLeft[2][3] * mfRight[3][1]) ;
	mfThis[2][2] = (mfLeft[2][0] * mfRight[0][2]) + (mfLeft[2][1] * mfRight[1][2]) + (mfLeft[2][2] * mfRight[2][2]) + (mfLeft[2][3] * mfRight[3][2]) ;
	mfThis[2][3] = (mfLeft[2][0] * mfRight[0][3]) + (mfLeft[2][1] * mfRight[1][3]) + (mfLeft[2][2] * mfRight[2][3]) + (mfLeft[2][3] * mfRight[3][3]) ;
	mfThis[3][0] = (mfLeft[3][0] * mfRight[0][0]) + (mfLeft[3][1] * mfRight[1][0]) + (mfLeft[3][2] * mfRight[2][0]) + (mfLeft[3][3] * mfRight[3][0]) ;
	mfThis[3][1] = (mfLeft[3][0] * mfRight[0][1]) + (mfLeft[3][1] * mfRight[1][1]) + (mfLeft[3][2] * mfRight[2][1]) + (mfLeft[3][3] * mfRight[3][1]) ;
	mfThis[3][2] = (mfLeft[3][0] * mfRight[0][2]) + (mfLeft[3][1] * mfRight[1][2]) + (mfLeft[3][2] * mfRight[2][2]) + (mfLeft[3][3] * mfRight[3][2]) ;
	mfThis[3][3] = (mfLeft[3][0] * mfRight[0][3]) + (mfLeft[3][1] * mfRight[1][3]) + (mfLeft[3][2] * mfRight[2][3]) + (mfLeft[3][3] * mfRight[3][3]) ;

	// Total Adds 48, Total Multiplies 64 
}



/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Clamp - limit matrix value so that they can be converted to int's
/////////////////////////////////////////////////////////////////////////////
void CMtxF__Clamp(CMtxF mfThis)
{
	int 		r, c ;

	for (r=0; r<4; r++)
	{
   	for (c=0; c<4; c++)
		{
			// Range check matrix value
			if (mfThis[r][c] > 32767.0)
				mfThis[r][c] = 32767.0 ;
			else
			if (mfThis[r][c] < -32767.0)
				mfThis[r][c] = -32767.0 ;
		}
	}
}



/////////////////////////////////////////////////////////////////////////////
//	CMtxF__VectorMult
/////////////////////////////////////////////////////////////////////////////
void CMtxF__VectorMult(CMtxF mfThis, const CVector3 *pvIn, CVector3 *pvOut)
{
   pvOut->x = mfThis[0][0]*pvIn->x + mfThis[1][0]*pvIn->y
               + mfThis[2][0]*pvIn->z + mfThis[3][0];

   pvOut->y = mfThis[0][1]*pvIn->x + mfThis[1][1]*pvIn->y
               + mfThis[2][1]*pvIn->z + mfThis[3][1];

   pvOut->z = mfThis[0][2]*pvIn->x + mfThis[1][2]*pvIn->y
               + mfThis[2][2]*pvIn->z + mfThis[3][2];
}

void CMtxF__VectorMult4x4(CMtxF mfThis, const CVector3 *pvIn, CVector3 *pvOut)
{
   float divisor, invDivisor;
	
	pvOut->x = mfThis[0][0]*pvIn->x + mfThis[1][0]*pvIn->y
               + mfThis[2][0]*pvIn->z + mfThis[3][0];

   pvOut->y = mfThis[0][1]*pvIn->x + mfThis[1][1]*pvIn->y
               + mfThis[2][1]*pvIn->z + mfThis[3][1];

   pvOut->z = mfThis[0][2]*pvIn->x + mfThis[1][2]*pvIn->y
               + mfThis[2][2]*pvIn->z + mfThis[3][2];
   
	divisor	= mfThis[0][3]*pvIn->x + mfThis[1][3]*pvIn->y
					+ mfThis[2][3]*pvIn->z + mfThis[3][3];
   
   if (divisor != 0)
	{
		invDivisor = 1/divisor;

		pvOut->x *= invDivisor;
		pvOut->y *= invDivisor;
		pvOut->z *= invDivisor;
	}
}


/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Identity
/////////////////////////////////////////////////////////////////////////////
#if MATRIX_OPTIMISE
void CMtxF__Identity(CMtxF mfThis)
{
	mfThis[0][0] = mfThis[1][1] = mfThis[2][2] = mfThis[3][3] = 1 ;

	mfThis[0][1] =	mfThis[0][2] = mfThis[0][3] =
	mfThis[1][0] = mfThis[1][2] = mfThis[1][3] =
	mfThis[2][0] = mfThis[2][1] = mfThis[2][3] =
	mfThis[3][0] = mfThis[3][1] = mfThis[3][2] = 0 ;
}
#else
void CMtxF__Identity(CMtxF mfThis)
{
	int	i, j;

	for (i=0; i<4; i++)
		for (j=0; j<4; j++)
			mfThis[i][j] = (i == j) ? 1 : 0;
}
#endif




/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Translate
/////////////////////////////////////////////////////////////////////////////
#if MATRIX_OPTIMISE
void CMtxF__Translate(CMtxF mfThis, float X, float Y, float Z)
{
	mfThis[0][0] = mfThis[1][1] = mfThis[2][2] = mfThis[3][3] = 1 ;
 
	mfThis[0][1] = mfThis[0][2] = mfThis[0][3] = mfThis[1][0] =
	mfThis[1][2] = mfThis[1][3] = mfThis[2][0] = mfThis[2][1] =
	mfThis[2][3] = 0 ;

	mfThis[3][0] = X ;
	mfThis[3][1] = Y ;
	mfThis[3][2] = Z ;
}
#else
void CMtxF__Translate(CMtxF mfThis, float X, float Y, float Z)
{
	CMtxF__Identity(mfThis);

	mfThis[3][0] = X;
	mfThis[3][1] = Y;
	mfThis[3][2] = Z;
}
#endif



/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Scale
/////////////////////////////////////////////////////////////////////////////
#if MATRIX_OPTIMISE
void CMtxF__Scale(CMtxF mfThis, float X, float Y, float Z)
{
	mfThis[0][0] = X ;
	mfThis[1][1] = Y ;
	mfThis[2][2] = Z ;
	mfThis[3][3] = 1 ;

	mfThis[0][1] = mfThis[0][2] = mfThis[0][3] =
	mfThis[1][0] = mfThis[1][2] = mfThis[1][3] =
	mfThis[2][0] = mfThis[2][1] = mfThis[2][3] =
	mfThis[3][0] = mfThis[3][1] = mfThis[3][2] = 0 ;
}
#else
void CMtxF__Scale(CMtxF mfThis, float X, float Y, float Z)
{
	CMtxF__Identity(mfThis);

	mfThis[0][0] = X;
	mfThis[1][1] = Y;
	mfThis[2][2] = Z;
}
#endif



/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Rotate
/////////////////////////////////////////////////////////////////////////////
#if MATRIX_OPTIMISE
void CMtxF__Rotate(CMtxF mfThis, float Theta, float X, float Y, float Z)
{
	float	sine ;
	float	cosine ;
	float	ab, bc, ca, t ;

	sine = sin(Theta) ;
	cosine = cos(Theta) ;

	t = (1-cosine) ;
	ab = X*Y*t ;
	bc = Y*Z*t ;
	ca = Z*X*t ;

	mfThis[0][3] = mfThis[1][3] = mfThis[2][3] =
	mfThis[3][0] = mfThis[3][1] = mfThis[3][2] = 0 ;
	mfThis[3][3] = 1 ;

	t = X*X ;
	X *= sine ;
	mfThis[0][0] = t+cosine*(1-t) ;
	mfThis[2][1] = bc-X ;
	mfThis[1][2] = bc+X ; 

	t = Y*Y ;
	Y *= sine ;
	mfThis[1][1] = t+cosine*(1-t) ;
	mfThis[2][0] = ca+Y ;
	mfThis[0][2] = ca-Y ;

	t = Z*Z ;
	Z *= sine ;
	mfThis[2][2] = t+cosine*(1-t) ;
	mfThis[1][0] = ab-Z ;
	mfThis[0][1] = ab+Z ;
}
#else
void CMtxF__Rotate(CMtxF mfThis, float Theta, float X, float Y, float Z)
{
	//static float	dtor = 3.1415926 / 180.0;
	float	sine;
	float	cosine;
	float	ab, bc, ca, t;

	//guNormalize(&X, &Y, &Z);
	//Theta *= dtor;

	sine = sin(Theta);
	cosine = cos(Theta);

	t = (1-cosine);
	ab = X*Y*t;
	bc = Y*Z*t;
	ca = Z*X*t;

	CMtxF__Identity(mfThis);

	t = X*X;
	mfThis[0][0] = t+cosine*(1-t);
	mfThis[2][1] = bc-X*sine;
	mfThis[1][2] = bc+X*sine;

	t = Y*Y;
	mfThis[1][1] = t+cosine*(1-t);
	mfThis[2][0] = ca+Y*sine;
	mfThis[0][2] = ca-Y*sine;

	t = Z*Z;
	mfThis[2][2] = t+cosine*(1-t);
	mfThis[1][0] = ab-Z*sine;
	mfThis[0][1] = ab+Z*sine;
}
#endif



/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Print
/////////////////////////////////////////////////////////////////////////////
void CMtxF__Print(CMtxF mfThis)
{
	int	i;

	TRACE0("CMtxF values:\r\n");
	for (i=0; i<4; i++)
		TRACE4("  %f  %f  %f  %f\r\n", mfThis[i][0], mfThis[i][1], mfThis[i][2], mfThis[i][3]);
}


/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Copy
/////////////////////////////////////////////////////////////////////////////
#if MATRIX_OPTIMISE
#define	MATRIX_COLUMN_COPY(r)				\
 	mfThis[r][0] = mfSource[r][0] ; \
	mfThis[r][1] = mfSource[r][1] ; \
	mfThis[r][2] = mfSource[r][2] ; \
	mfThis[r][3] = mfSource[r][3] ;

void CMtxF__Copy(CMtxF mfThis, CMtxF mfSource)
{
	MATRIX_COLUMN_COPY(0) ;
	MATRIX_COLUMN_COPY(1) ;
	MATRIX_COLUMN_COPY(2) ;
	MATRIX_COLUMN_COPY(3) ;
}

#else
void CMtxF__Copy(CMtxF mfThis, CMtxF mfSource)
{
	int	i, j;

	for (i=0; i<4; i++)
		for (j=0; j<4; j++)
			mfThis[i][j] = mfSource[i][j];
}
#endif



/////////////////////////////////////////////////////////////////////////////
//	CMtxF__Invert
/////////////////////////////////////////////////////////////////////////////
void CMtxF__Invert(CMtxF mfThis, CMtxF mfIn)
{
	float	det, invDet;

   // won't work in place
	ASSERT(mfThis != mfIn);

   // complex matrix inversions not supported
	ASSERT(mfIn[0][3] == 0);
	ASSERT(mfIn[1][3] == 0);
	ASSERT(mfIn[2][3] == 0);
	ASSERT(mfIn[3][3] == 1);

   det = mfIn[0][0]*mfIn[1][1]*mfIn[2][2] - mfIn[0][0]*mfIn[2][1]*mfIn[1][2]
       - mfIn[1][0]*mfIn[0][1]*mfIn[2][2] + mfIn[1][0]*mfIn[2][1]*mfIn[0][2]
       + mfIn[2][0]*mfIn[0][1]*mfIn[1][2] - mfIn[2][0]*mfIn[1][1]*mfIn[0][2];
   if (det == 0)
   {
      ASSERT(FALSE);
		CMtxF__Copy(mfThis, mfIn);
   }
   else
   {
		invDet = 1/det;

   	mfThis[0][0] = (mfIn[1][1]*mfIn[2][2]-mfIn[2][1]*mfIn[1][2])*invDet;
   	mfThis[0][1] = -(mfIn[0][1]*mfIn[2][2]-mfIn[2][1]*mfIn[0][2])*invDet;
   	mfThis[0][2] = (mfIn[0][1]*mfIn[1][2]-mfIn[1][1]*mfIn[0][2])*invDet;
   	mfThis[0][3] = 0;

   	mfThis[1][0] = (-mfIn[1][0]*mfIn[2][2]+mfIn[2][0]*mfIn[1][2])*invDet;
   	mfThis[1][1] = (mfIn[0][0]*mfIn[2][2]-mfIn[2][0]*mfIn[0][2])*invDet;
   	mfThis[1][2] = -(mfIn[0][0]*mfIn[1][2]-mfIn[1][0]*mfIn[0][2])*invDet;
   	mfThis[1][3] = 0;

   	mfThis[2][0] = -(-mfIn[1][0]*mfIn[2][1]+mfIn[2][0]*mfIn[1][1])*invDet;
   	mfThis[2][1] = (-mfIn[0][0]*mfIn[2][1]+mfIn[2][0]*mfIn[0][1])*invDet;
   	mfThis[2][2] = -(-mfIn[0][0]*mfIn[1][1]+mfIn[1][0]*mfIn[0][1])*invDet;
   	mfThis[2][3] = 0;

   	mfThis[3][0] = (-mfIn[1][0]*mfIn[2][1]*mfIn[3][2]+mfIn[1][0]*mfIn[2][2]*mfIn[3][1]
   			+mfIn[2][0]*mfIn[1][1]*mfIn[3][2]-mfIn[2][0]*mfIn[1][2]*mfIn[3][1]
   			-mfIn[3][0]*mfIn[1][1]*mfIn[2][2]+mfIn[3][0]*mfIn[2][1]*mfIn[1][2])*invDet;
   	mfThis[3][1] = (mfIn[0][0]*mfIn[2][1]*mfIn[3][2]-mfIn[0][0]*mfIn[2][2]*mfIn[3][1]
   			-mfIn[2][0]*mfIn[0][1]*mfIn[3][2]+mfIn[2][0]*mfIn[0][2]*mfIn[3][1]
   			+mfIn[3][0]*mfIn[0][1]*mfIn[2][2]-mfIn[3][0]*mfIn[2][1]*mfIn[0][2])*invDet;
   	mfThis[3][2] = -(mfIn[0][0]*mfIn[1][1]*mfIn[3][2]-mfIn[0][0]*mfIn[1][2]*mfIn[3][1]
   			-mfIn[1][0]*mfIn[0][1]*mfIn[3][2]+mfIn[1][0]*mfIn[0][2]*mfIn[3][1]
   			+mfIn[3][0]*mfIn[0][1]*mfIn[1][2]-mfIn[3][0]*mfIn[1][1]*mfIn[0][2])*invDet;
   	mfThis[3][3] = 1;
   }
}

// CQuatern
/////////////////////////////////////////////////////////////////////////////

//#define Q2M_NORMALIZE
void CQuatern__ToMatrix(CQuatern *pqThis, CMtxF mfRotate)
{
	float		x, x2,
				y, y2,
				z, z2,
				t, t2;
#ifdef Q2M_NORMALIZE
	float		denom, invDenom;
#endif

	float		xy2,
				tz2,
				xz2,
				ty2,
				yz2,
				tx2 ;

	x 	= pqThis->x;
	x2 = x*x;

	y 	= pqThis->y;
	y2	= y*y;

	z	= pqThis->z;
	z2 = z*z;

	t	= pqThis->t;
	t2 = t*t;

#ifdef Q2M_NORMALIZE
	denom = t2 + x2 + y2 + z2;
	if (denom == 0)
		invDenom = 1;
	else
		invDenom = 1/denom;

	mfRotate[0][0] = (t2 + x2 - y2 - z2)*invDenom;
	mfRotate[1][0] = (2*x*y - 2*t*z)		*invDenom;
   mfRotate[2][0] = (2*x*z + 2*t*y)		*invDenom;
   mfRotate[3][0] = 0;

   mfRotate[0][1] = (2*x*y + 2*t*z)		*invDenom;
   mfRotate[1][1] = (t2 - x2 + y2 - z2)*invDenom;
   mfRotate[2][1] = (2*y*z - 2*t*x)		*invDenom;
   mfRotate[3][1] = 0;

   mfRotate[0][2] = (2*x*z - 2*t*y)		*invDenom;
   mfRotate[1][2] = (2*y*z + 2*t*x)		*invDenom;
   mfRotate[2][2] = (t2 - x2 - y2 + z2)*invDenom;
   mfRotate[3][2] = 0;

   mfRotate[0][3] = 0;
   mfRotate[1][3] = 0;
   mfRotate[2][3] = 0;
	mfRotate[3][3] = 1;
#else

	// USING THIS ONE
	xy2 = 2*x*y ;
	tz2 = 2*t*z ;
	xz2 = 2*x*z ;
	ty2 = 2*t*y ;
	yz2 = 2*y*z ;
	tx2 = 2*t*x ;


	mfRotate[0][0] = t2 + x2 - y2 - z2;
   mfRotate[0][1] = xy2 + tz2 ; //2*x*y + 2*t*z;
   mfRotate[0][2] = xz2 - ty2 ; //2*x*z - 2*t*y;
   mfRotate[0][3] = 0;

	mfRotate[1][0] = xy2 - tz2 ; //2*x*y - 2*t*z;
   mfRotate[1][1] = t2 - x2 + y2 - z2;
   mfRotate[1][2] = yz2 + tx2 ; //2*y*z + 2*t*x;
   mfRotate[1][3] = 0;

   mfRotate[2][0] = xz2 + ty2 ; //2*x*z + 2*t*y;
   mfRotate[2][1] = yz2 - tx2 ; //2*y*z - 2*t*x;
   mfRotate[2][2] = t2 - x2 - y2 + z2;
   mfRotate[2][3] = 0;

   mfRotate[3][0] = 0;
   mfRotate[3][1] = 0;
   mfRotate[3][2] = 0;
	mfRotate[3][3] = 1;
#endif
}

void CQuatern__Mult(CQuatern *pqThis, const CQuatern *pqLeft, const CQuatern *pqRight)
{
   pqThis->x = pqRight->t*pqLeft->x  - pqRight->z*pqLeft->y + pqRight->y*pqLeft->z + pqRight->x*pqLeft->t;
   pqThis->y = pqRight->z*pqLeft->x  + pqRight->t*pqLeft->y - pqRight->x*pqLeft->z + pqRight->y*pqLeft->t;
   pqThis->z = -pqRight->y*pqLeft->x + pqRight->x*pqLeft->y + pqRight->t*pqLeft->z + pqRight->z*pqLeft->t;
   pqThis->t = -pqRight->x*pqLeft->x - pqRight->y*pqLeft->y - pqRight->z*pqLeft->z + pqRight->t*pqLeft->t;
}

void CQuatern__Normalize(CQuatern *pqThis)
{
	float 	mag, invMag;

	mag = CQuatern__Magnitude(pqThis);
	ASSERT(mag != 0);

	if (mag != 0)
	{
		invMag = 1/mag;

		CQuatern__MultScaler(pqThis, pqThis, invMag);
	}
}

//#define BLEND_COMPLEX
void CQuatern__BlendLinear(CQuatern *pqThis, float u, CQuatern *pqA, CQuatern *pqB)
{
#ifdef BLEND_COMPLEX

	CQuatern		qBN;
	float			dot, dotN;

	// try both directions
	qBN = *pqB;
	CQuatern__Negate(&qBN);

	dot 	= CQuatern__Dot(pqA, pqB);
	dotN	= CQuatern__Dot(pqA, &qBN);

	if (dot < dotN)
		pqB = &qBN;

	pqThis->x = BlendFLOAT(u, pqA->x, pqB->x);
	pqThis->y = BlendFLOAT(u, pqA->y, pqB->y);
	pqThis->z = BlendFLOAT(u, pqA->z, pqB->z);
	pqThis->t = BlendFLOAT(u, pqA->t, pqB->t);

#else

	// simple version
	pqThis->x = BlendFLOAT(u, pqA->x, pqB->x);
	pqThis->y = BlendFLOAT(u, pqA->y, pqB->y);
	pqThis->z = BlendFLOAT(u, pqA->z, pqB->z);
	pqThis->t = BlendFLOAT(u, pqA->t, pqB->t);

#endif
}

void CQuatern__BlendSpherical(CQuatern *pqThis, float u, CQuatern *pqA, CQuatern *pqB)
{
	CQuatern		qBN;
	float			dot, dotN,
					theta, sinTheta, invSinTheta,
					vA, vB;

	// try both directions
	qBN = *pqB;
	CQuatern__Negate(&qBN);

	dot 	= CQuatern__Dot(pqA, pqB);
	dotN	= CQuatern__Dot(pqA, &qBN);

	if (dot < dotN)
	{
		dot = dotN;
		pqB = &qBN;
	}

	theta = acos(dot);
	sinTheta = sin(theta);

   if (sinTheta == 0)
   {
		*pqThis = *pqA;
   }
   else
   {
      invSinTheta = 1/sinTheta;

		vA = sin((1-u)*theta) * invSinTheta;
		vB = sin(u*theta) * invSinTheta;

		if (dot < dotN)
			pqB = &qBN;

		pqThis->x = vA*pqA->x + vB*pqB->x;
		pqThis->y = vA*pqA->y + vB*pqB->y;
		pqThis->z = vA*pqA->z + vB*pqB->z;
		pqThis->t = vA*pqA->t + vB*pqB->t;

		// optional
		//CQuatern__Normalize(pqThis);
   }
}

void CQuatern__BlendThreshold(CQuatern *pqThis, float u, CQuatern *pqA, CQuatern *pqB)
{
	CQuatern		qBN;
	float			dot, dotN,
					theta, sinTheta, invSinTheta,
					vA, vB;

	// try both directions
	qBN = *pqB;
	CQuatern__Negate(&qBN);

	dot 	= CQuatern__Dot(pqA, pqB);
	dotN	= CQuatern__Dot(pqA, &qBN);

	if (dot < dotN)
	{
		dot = dotN;
		pqB = &qBN;
	}

#define COS_THRESHOLD_ANGLE	 0.7071067811865	// cos(45) degrees
	if (dot > COS_THRESHOLD_ANGLE)
	{
		pqThis->x = BlendFLOAT(u, pqA->x, pqB->x);
		pqThis->y = BlendFLOAT(u, pqA->y, pqB->y);
		pqThis->z = BlendFLOAT(u, pqA->z, pqB->z);
		pqThis->t = BlendFLOAT(u, pqA->t, pqB->t);

		CQuatern__Normalize(pqThis);
	}
	else
	{
		theta = acos(dot);
		sinTheta = sin(theta);

		if (sinTheta == 0)
		{
			*pqThis = *pqA;
		}
		else
		{
			invSinTheta = 1/sinTheta;

			vA = sin((1-u)*theta) * invSinTheta;
			vB = sin(u*theta) * invSinTheta;

			if (dot < dotN)
				pqB = &qBN;

			pqThis->x = vA*pqA->x + vB*pqB->x;
			pqThis->y = vA*pqA->y + vB*pqB->y;
			pqThis->z = vA*pqA->z + vB*pqB->z;
			pqThis->t = vA*pqA->t + vB*pqB->t;
		}

		// optional
		//CQuatern__Normalize(pqThis);
	}
}

//#define GETCLOSER_MAX_DEGREE_INC		35
#define GETCLOSER_MAX_DEGREE_INC		25
#define GETCLOSER_MIN_DEGREE_INC		0.01
void CQuatern__GetCloser(CQuatern *pqThis, CQuatern *pqTarget)
{
	CQuatern		qResult;
	float			dot, theta, deltaTheta, u;

	dot = CQuatern__Dot(pqThis, pqTarget);
	theta = acos(dot);

	if (theta != 0)
	{
		deltaTheta = (theta*(ANGLE_DTOR(GETCLOSER_MAX_DEGREE_INC)/ANGLE_PI) + ANGLE_DTOR(GETCLOSER_MIN_DEGREE_INC))*frame_increment;

		u = max(0, min(1, 1 - (theta - deltaTheta)/theta));

		CQuatern__Blend(&qResult, u, pqThis, pqTarget);

		*pqThis = qResult;
	}
}

void CQuatern__Print(CQuatern *pqThis)
{
	TRACE4("CQuatern: x:%f, y:%f, z:%f, t:%f\r\n",
			 pqThis->x, pqThis->y, pqThis->z, pqThis->t);
}

// CVector3
/////////////////////////////////////////////////////////////////////////////

void CVector3__Add(CVector3 *pvThis, CVector3 *pvLeft, CVector3 *pvRight)
{
	pvThis->x = pvLeft->x + pvRight->x;
	pvThis->y = pvLeft->y + pvRight->y;
	pvThis->z = pvLeft->z + pvRight->z;
}

void CVector3__Subtract(CVector3 *pvThis, CVector3 *pvLeft, CVector3 *pvRight)
{
	pvThis->x = pvLeft->x - pvRight->x;
	pvThis->y = pvLeft->y - pvRight->y;
	pvThis->z = pvLeft->z - pvRight->z;
}

void CVector3__MultScaler(CVector3 *pvThis, CVector3 *pvIn, float Scaler)
{
	pvThis->x = pvIn->x * Scaler;
	pvThis->y = pvIn->y * Scaler;
	pvThis->z = pvIn->z * Scaler;
}

void CVector3__Blend(CVector3 *pvThis, float u, CVector3 *pvLeft, CVector3 *pvRight)
{
	pvThis->x = BlendFLOAT(u, pvLeft->x, pvRight->x);
	pvThis->y = BlendFLOAT(u, pvLeft->y, pvRight->y);
	pvThis->z = BlendFLOAT(u, pvLeft->z, pvRight->z);
}

void CVector3__Cross(CVector3 *pvThis, CVector3 *pvLeft, CVector3 *pvRight)
{
	pvThis->x = pvLeft->y*pvRight->z - pvLeft->z*pvRight->y;
	pvThis->y = pvLeft->z*pvRight->x - pvLeft->x*pvRight->z;
	pvThis->z = pvLeft->x*pvRight->y - pvLeft->y*pvRight->x;
}

void CVector3__Normalize(CVector3 *pvThis)
{
	float magnitude, invMagnitude;

	magnitude = CVector3__Magnitude(pvThis);
	if (magnitude != 0)
	{
		invMagnitude = 1/magnitude;
		pvThis->x *= invMagnitude;
		pvThis->y *= invMagnitude;
		pvThis->z *= invMagnitude;
	}
}

// uRandom should range from 0 to 1 (1 is completely random)
// output is not normalized (fine for direction)
CVector3 CVector3__RandomizeDirection(CVector3 *pvThis, float uRandom)
{
	CVector3 vRandom, vOut;

	vRandom.x = RANDOM(20000) - 10000;
	vRandom.y = RANDOM(20000) - 10000;
	vRandom.z = RANDOM(20000) - 10000;

	CVector3__Normalize(&vRandom);
	CVector3__Normalize(pvThis);

	CVector3__Blend(&vOut, uRandom, pvThis, &vRandom);

	return vOut;
}

// uRandom should range from 0 to 1 (1 is completely random)
// output is not normalized (fine for direction)
CVector3 CVector3__RandomizeDirectionX(CVector3 *pvThis, float uRandom)
{
	CVector3 vRandom, vOut;

	vRandom.x = (RANDOM(20000) - 10000) * 0.0001;
	vRandom.y = pvThis->y;
	vRandom.z = pvThis->z;

	CVector3__Normalize(&vRandom);
	CVector3__Normalize(pvThis);

	CVector3__Blend(&vOut, uRandom, pvThis, &vRandom);

	return vOut;
}

// uRandom should range from 0 to 1 (1 is completely random)
// output is not normalized (fine for direction)
CVector3 CVector3__RandomizeDirectionY(CVector3 *pvThis, float uRandom)
{
	CVector3 vRandom, vOut;

	vRandom.x = pvThis->x;
	vRandom.y = (RANDOM(20000) - 10000) * 0.0001;
	vRandom.z = pvThis->z;

	CVector3__Normalize(&vRandom);
	CVector3__Normalize(pvThis);

	CVector3__Blend(&vOut, uRandom, pvThis, &vRandom);

	return vOut;
}

// uRandom should range from 0 to 1 (1 is completely random)
// output is not normalized (fine for direction)
CVector3 CVector3__RandomizeDirectionZ(CVector3 *pvThis, float uRandom)
{
	CVector3 vRandom, vOut;

	vRandom.x = pvThis->x;
	vRandom.y = pvThis->y;
	vRandom.z = (RANDOM(20000) - 10000) * 0.0001;

	CVector3__Normalize(&vRandom);
	CVector3__Normalize(pvThis);

	CVector3__Blend(&vOut, uRandom, pvThis, &vRandom);

	return vOut;
}

void CVector3__YIntersect(CVector3 *pvThis, CVector3 *pvStart, CVector3 *pvEnd, float Y)
{
	float		dy, u;

	dy = pvEnd->y - pvStart->y;
	if (dy == 0)
	{
		*pvThis = *pvStart;
	}
	else
	{
		u = (Y - pvStart->y)/dy;

		pvThis->x = pvStart->x + u*(pvEnd->x - pvStart->x);
		pvThis->y = Y;
		pvThis->z = pvStart->z + u*(pvEnd->z - pvStart->z);
	}
}

CVector3 CVector3__Reflect(CVector3 *pThis, CVector3 *pvSurfaceUnitNormal, float EnergyFactor)
{
	CVector3		vReflect;
	float			dot;

	dot = CVector3__Dot(pThis, pvSurfaceUnitNormal);

	vReflect.x = pThis->x - (1 + EnergyFactor)*pvSurfaceUnitNormal->x*dot;
	vReflect.y = pThis->y - (1 + EnergyFactor)*pvSurfaceUnitNormal->y*dot;
	vReflect.z = pThis->z - (1 + EnergyFactor)*pvSurfaceUnitNormal->z*dot;

	return vReflect;
}

CVector3 CVector3__Project(CVector3 *pvThis, CVector3 *pvSurfaceUnitNormal)
{
	CVector3	vProjected;
	float		dot;

	dot = CVector3__Dot(pvThis, pvSurfaceUnitNormal);

	vProjected.x = pvThis->x - dot*pvSurfaceUnitNormal->x;
	vProjected.y = pvThis->y - dot*pvSurfaceUnitNormal->y;
	vProjected.z = pvThis->z - dot*pvSurfaceUnitNormal->z;

	return vProjected;
}

CVector3 CVector3__ProjectCrease(CVector3 *pvThis, CVector3 *pvNormalA, CVector3 *pvNormalB)
{
	CVector3		vCross,
					vProject;
	float			dot;

	CVector3__Cross(&vCross, pvNormalA, pvNormalB);
	CVector3__Normalize(&vCross);

	dot = CVector3__Dot(pvThis, &vCross);

	CVector3__MultScaler(&vProject, &vCross, dot);

	return vProject;
}

CVector3 CVector3__Redirect(CVector3 *pvThis, CVector3 *pvSurfaceUnitNormal)
{
	CVector3		vProjected;
	float			magProj, magRatio;

	vProjected = CVector3__Project(pvThis, pvSurfaceUnitNormal);
	
	magProj = CVector3__Magnitude(&vProjected);
	if (magProj != 0)
	{
		magRatio = CVector3__Magnitude(pvThis)/magProj;

		vProjected.x *= magRatio;
		vProjected.y *= magRatio;
		vProjected.z *= magRatio;
	}
	
	return vProjected;
}

BOOL CVector3__Clamp(CVector3 *pvThis, float MaxVal)
{
	float	magSq, mag;

	magSq = CVector3__MagnitudeSquared(pvThis);

	if (magSq > (MaxVal*MaxVal))
	{
		mag = sqrt(magSq);

		if (mag != 0)
		{
			CVector3__MultScaler(pvThis, pvThis, MaxVal/mag);

			return TRUE;
		}
	}

	return FALSE;
}

CQuatern CVector3__GetDirectionRotation(CVector3 *pvThis)
{
	CQuatern	qRot;
	CVector3	vUnitVelocity,
				vZ,
				vAxis;
	float		mag,
				theta, cosTheta;

	mag = CVector3__Magnitude(pvThis);
	if (mag == 0)
	{
		CQuatern__Identity(&qRot);
	}
	else
	{
		CVector3__MultScaler(&vUnitVelocity, pvThis, 1/mag);

		vZ.x = 0;
		vZ.y = 0;
		vZ.z = 1;

		cosTheta = CVector3__Dot(&vUnitVelocity, &vZ);
		theta = acos(cosTheta);

		CVector3__Cross(&vAxis, &vZ, &vUnitVelocity);
		CVector3__Normalize(&vAxis);

		CQuatern__BuildFromAxisAngle(&qRot, vAxis.x, vAxis.y, vAxis.z, theta);
	}

	return qRot;
}

void CVector3__Print(CVector3 *pvThis)
{
	TRACE3("CVector3: x:%f, y:%f, z:%f\r\n",
			 pvThis->x,
			 pvThis->y,
			 pvThis->z);
}

/////////////////////////////////////////////////////////////////////////////
// Extra CVector3 functions by S.Broumley.
/////////////////////////////////////////////////////////////////////////////


/*****************************************************************************
*
*	Function:		CVector3__XZAngle()
*
******************************************************************************
*
*	Description:	Returns (x,z) angle between vector and (0,0)
*
*	Inputs:			*pThis	-	Ptr to vector
*
*	Outputs:			xz angle in radians
*
*****************************************************************************/
FLOAT CVector3__XZAngle(CVector3 *pThis)
{
	float		dx, dz,
				magDelta,
				dot, theta;

	dx = pThis->x ;
	dz = pThis->z ;

	magDelta = (dx*dx) + (dz*dz) ;
	if (magDelta == 0)
		return 0 ;

	magDelta = sqrt(magDelta) ;

	dot = max(-1, min(1, -dz/magDelta)) ;
	theta = acos(dot) ;

	return (-dx > 0) ? theta : -theta ;
}



/*****************************************************************************
*
*	Function:		CVector3__XYAngle()
*
******************************************************************************
*
*	Description:	Returns (x,y) angle between vector and (0,0)
*
*	Inputs:			*pThis	-	Ptr to vector
*
*	Outputs:			xy angle in radians
*
*****************************************************************************/
FLOAT CVector3__XYAngle(CVector3 *pThis)
{
	FLOAT		hyp, dx,dy,dz, costheta, theta ;

	dx = pThis->x ;
	dy = pThis->y ;
	dz = pThis->z ;

	hyp = (dx*dx) + (dy*dy) + (dz*dz) ;
	if (hyp == 0)
		return 0 ;

	hyp = sqrt(hyp) ;
	costheta = dy / hyp ;
	theta = acos(costheta) - (ANGLE_PI/2) ;

	return theta ;
}


/*****************************************************************************
*
*	Function:		CVector3__DistSqr()
*
******************************************************************************
*
*	Description:	Returns the distance squared between two vectors
*
*	Inputs:			*pThis, *pvPos	-	Ptr to vector
*
*	Outputs:			FLOAT	Distance squared between vectors
*
*****************************************************************************/
FLOAT CVector3__DistSqr(CVector3 *pThis, CVector3 *pvPos)
{
	FLOAT		dx,dy,dz ;

	dx = pThis->x - pvPos->x ;
	dy = pThis->y - pvPos->y ;
	dz = pThis->z - pvPos->z ;

	return (dx * dx) + (dy * dy) + (dz * dz) ;
}

FLOAT CVector3__Dist(CVector3 *pThis, CVector3 *pvPos)
{
	return sqrt(CVector3__DistSqr(pThis, pvPos)) ;
}




/////////////////////////////////////////////////////////////////////////////

#define RANDOM_SEED ((DWORD) 3824563683)
#define RANDOM_ADD  ((DWORD) 1479838765)
#define RANDOM_MULT ((DWORD) 2823445331)

void InitializeRandomSeed()
{
	random_value = RANDOM_SEED ;
	sound_random_value = RANDOM_SEED ;
}

int RandomSwapWord()
{
	// Fudge tastic to get attract mode to work properly!!
	if (CAttractDemo__Active())
		random_value = game_frame_number*RANDOM_MULT + RANDOM_ADD ;
	else
		random_value = random_value*RANDOM_MULT + RANDOM_ADD ;

	return (int) (((random_value << 16) | (random_value >> 16)) & 0x7FFFFFFF) ;
}


int SoundRandomSwapWord()
{
	// Fudge tastic to get attract mode to work properly!!
	if (CAttractDemo__Active())
		sound_random_value = game_frame_number*RANDOM_MULT + RANDOM_ADD ;
	else
		sound_random_value = sound_random_value*RANDOM_MULT + RANDOM_ADD ;

	return (int) (((sound_random_value << 16) | (sound_random_value >> 16)) & 0x7FFFFFFF) ;
}


float RandomFloat(float Max)
{
	return (((RandomSwapWord()%928467291)*Max)/928467290);
}

float BlendRotFLOAT(float u, float A, float B)
{
	float newB, blended;
	
	NormalizeRotation(&A);
	NormalizeRotation(&B);

	if (A > B)
	{
		newB = B + 2*ANGLE_PI;
		if ((newB - A) < (A - B))
			B = newB;
	}
	else
	{
		newB = B - 2*ANGLE_PI;
		if ((A - newB) < (B - A))
			B = newB;
	}

	blended = BlendFLOAT(u, A, B);
	NormalizeRotation(&blended);
	
	return blended;
}

float RotDifference(float A, float B)
{
	float newB;
	
	NormalizeRotation(&A);
	NormalizeRotation(&B);
	
	if (A > B)
	{
		newB = B + 2*ANGLE_PI;
		if ((newB - A) < (A - B))
			B = newB;
	}
	else
	{
		newB = B - 2*ANGLE_PI;
		if ((A - newB) < (B - A))
			B = newB;
	}

	return A - B;
}

/*
void NormalizeRotation(float *pTheta)
{
	ASSERT(pTheta);

	if (*pTheta < -ANGLE_PI)
		*pTheta += 2*ANGLE_PI;
	else if (*pTheta > ANGLE_PI)
		*pTheta -= 2*ANGLE_PI;
}
*/

void NormalizeRotation(float *pTheta)
{
	ASSERT(pTheta);

	while (*pTheta < -ANGLE_PI)
		*pTheta += 2*ANGLE_PI;

	while (*pTheta >= ANGLE_PI)
		*pTheta -= 2*ANGLE_PI;
}

// polynomial approximation
/*
float acos(float x)
{
	int				i;
	float 			val, x2, f;
	//static float 	coef[] = { -1.0/6.0, -3.0/40.0, -5.0/112.0, -35.0/1152.0, -63.0/2816.0 };

	static float 	coef[] = { -1.0/6.0, -3.0/40.0, -5.0/112.0, -35.0/1152.0, -63.0/2816.0,
									  -231.0/13312.0, -143.0/557056.0, -12155.0/1245184.0, -46189.0/5505024.0, -88179.0/12058624.0 };

	x2 = x*x;
	val = ANGLE_PI/2 - x;
	f = x;

	//for (i=0; i<5; i++)
	for (i=0; i<10; i++)
	{
		f *= x2;
		val += f*coef[i];
	}

	return val;
}
*/

// 4K lookup table
float acos(float x)
{
	float absX,
			xVal, xP1Val,
			fraction, blendVal;
	BOOL	negative;
	int	intAbsX;

	static BYTE act[] =
			{
				0x3F,0xC9,0x0F,0xDB,0x3F,0xC8,0xEF,0xD3,
				0x3F,0xC8,0xCF,0xCB,0x3F,0xC8,0xAF,0xC3,
				0x3F,0xC8,0x8F,0xBB,0x3F,0xC8,0x6F,0xB2,
				0x3F,0xC8,0x4F,0xAA,0x3F,0xC8,0x2F,0xA2,
				0x3F,0xC8,0x0F,0x9A,0x3F,0xC7,0xEF,0x92,
				0x3F,0xC7,0xCF,0x89,0x3F,0xC7,0xAF,0x81,
				0x3F,0xC7,0x8F,0x78,0x3F,0xC7,0x6F,0x70,
				0x3F,0xC7,0x4F,0x67,0x3F,0xC7,0x2F,0x5E,
				0x3F,0xC7,0x0F,0x55,0x3F,0xC6,0xEF,0x4C,
				0x3F,0xC6,0xCF,0x43,0x3F,0xC6,0xAF,0x3A,
				0x3F,0xC6,0x8F,0x30,0x3F,0xC6,0x6F,0x26,
				0x3F,0xC6,0x4F,0x1D,0x3F,0xC6,0x2F,0x13,
				0x3F,0xC6,0x0F,0x08,0x3F,0xC5,0xEE,0xFE,
				0x3F,0xC5,0xCE,0xF3,0x3F,0xC5,0xAE,0xE9,
				0x3F,0xC5,0x8E,0xDE,0x3F,0xC5,0x6E,0xD3,
				0x3F,0xC5,0x4E,0xC7,0x3F,0xC5,0x2E,0xBB,
				0x3F,0xC5,0x0E,0xB0,0x3F,0xC4,0xEE,0xA3,
				0x3F,0xC4,0xCE,0x97,0x3F,0xC4,0xAE,0x8A,
				0x3F,0xC4,0x8E,0x7D,0x3F,0xC4,0x6E,0x70,
				0x3F,0xC4,0x4E,0x63,0x3F,0xC4,0x2E,0x55,
				0x3F,0xC4,0x0E,0x47,0x3F,0xC3,0xEE,0x38,
				0x3F,0xC3,0xCE,0x29,0x3F,0xC3,0xAE,0x1A,
				0x3F,0xC3,0x8E,0x0B,0x3F,0xC3,0x6D,0xFB,
				0x3F,0xC3,0x4D,0xEB,0x3F,0xC3,0x2D,0xDB,
				0x3F,0xC3,0x0D,0xCA,0x3F,0xC2,0xED,0xB8,
				0x3F,0xC2,0xCD,0xA7,0x3F,0xC2,0xAD,0x95,
				0x3F,0xC2,0x8D,0x82,0x3F,0xC2,0x6D,0x70,
				0x3F,0xC2,0x4D,0x5C,0x3F,0xC2,0x2D,0x49,
				0x3F,0xC2,0x0D,0x35,0x3F,0xC1,0xED,0x20,
				0x3F,0xC1,0xCD,0x0B,0x3F,0xC1,0xAC,0xF6,
				0x3F,0xC1,0x8C,0xE0,0x3F,0xC1,0x6C,0xC9,
				0x3F,0xC1,0x4C,0xB2,0x3F,0xC1,0x2C,0x9B,
				0x3F,0xC1,0x0C,0x83,0x3F,0xC0,0xEC,0x6B,
				0x3F,0xC0,0xCC,0x52,0x3F,0xC0,0xAC,0x39,
				0x3F,0xC0,0x8C,0x1F,0x3F,0xC0,0x6C,0x04,
				0x3F,0xC0,0x4B,0xE9,0x3F,0xC0,0x2B,0xCE,
				0x3F,0xC0,0x0B,0xB2,0x3F,0xBF,0xEB,0x95,
				0x3F,0xBF,0xCB,0x78,0x3F,0xBF,0xAB,0x5A,
				0x3F,0xBF,0x8B,0x3B,0x3F,0xBF,0x6B,0x1C,
				0x3F,0xBF,0x4A,0xFD,0x3F,0xBF,0x2A,0xDC,
				0x3F,0xBF,0x0A,0xBC,0x3F,0xBE,0xEA,0x9A,
				0x3F,0xBE,0xCA,0x78,0x3F,0xBE,0xAA,0x55,
				0x3F,0xBE,0x8A,0x32,0x3F,0xBE,0x6A,0x0D,
				0x3F,0xBE,0x49,0xE9,0x3F,0xBE,0x29,0xC3,
				0x3F,0xBE,0x09,0x9D,0x3F,0xBD,0xE9,0x76,
				0x3F,0xBD,0xC9,0x4F,0x3F,0xBD,0xA9,0x26,
				0x3F,0xBD,0x88,0xFD,0x3F,0xBD,0x68,0xD4,
				0x3F,0xBD,0x48,0xA9,0x3F,0xBD,0x28,0x7E,
				0x3F,0xBD,0x08,0x52,0x3F,0xBC,0xE8,0x25,
				0x3F,0xBC,0xC7,0xF8,0x3F,0xBC,0xA7,0xC9,
				0x3F,0xBC,0x87,0x9A,0x3F,0xBC,0x67,0x6A,
				0x3F,0xBC,0x47,0x3A,0x3F,0xBC,0x27,0x08,
				0x3F,0xBC,0x06,0xD6,0x3F,0xBB,0xE6,0xA3,
				0x3F,0xBB,0xC6,0x6F,0x3F,0xBB,0xA6,0x3A,
				0x3F,0xBB,0x86,0x04,0x3F,0xBB,0x65,0xCE,
				0x3F,0xBB,0x45,0x97,0x3F,0xBB,0x25,0x5E,
				0x3F,0xBB,0x05,0x25,0x3F,0xBA,0xE4,0xEB,
				0x3F,0xBA,0xC4,0xB0,0x3F,0xBA,0xA4,0x74,
				0x3F,0xBA,0x84,0x37,0x3F,0xBA,0x63,0xFA,
				0x3F,0xBA,0x43,0xBB,0x3F,0xBA,0x23,0x7C,
				0x3F,0xBA,0x03,0x3B,0x3F,0xB9,0xE2,0xFA,
				0x3F,0xB9,0xC2,0xB7,0x3F,0xB9,0xA2,0x74,
				0x3F,0xB9,0x82,0x2F,0x3F,0xB9,0x61,0xEA,
				0x3F,0xB9,0x41,0xA3,0x3F,0xB9,0x21,0x5C,
				0x3F,0xB9,0x01,0x13,0x3F,0xB8,0xE0,0xCA,
				0x3F,0xB8,0xC0,0x7F,0x3F,0xB8,0xA0,0x34,
				0x3F,0xB8,0x7F,0xE7,0x3F,0xB8,0x5F,0x9A,
				0x3F,0xB8,0x3F,0x4B,0x3F,0xB8,0x1E,0xFB,
				0x3F,0xB7,0xFE,0xAA,0x3F,0xB7,0xDE,0x58,
				0x3F,0xB7,0xBE,0x05,0x3F,0xB7,0x9D,0xB1,
				0x3F,0xB7,0x7D,0x5C,0x3F,0xB7,0x5D,0x05,
				0x3F,0xB7,0x3C,0xAE,0x3F,0xB7,0x1C,0x55,
				0x3F,0xB6,0xFB,0xFB,0x3F,0xB6,0xDB,0xA0,
				0x3F,0xB6,0xBB,0x44,0x3F,0xB6,0x9A,0xE6,
				0x3F,0xB6,0x7A,0x88,0x3F,0xB6,0x5A,0x28,
				0x3F,0xB6,0x39,0xC7,0x3F,0xB6,0x19,0x65,
				0x3F,0xB5,0xF9,0x01,0x3F,0xB5,0xD8,0x9D,
				0x3F,0xB5,0xB8,0x37,0x3F,0xB5,0x97,0xCF,
				0x3F,0xB5,0x77,0x67,0x3F,0xB5,0x56,0xFD,
				0x3F,0xB5,0x36,0x92,0x3F,0xB5,0x16,0x26,
				0x3F,0xB4,0xF5,0xB9,0x3F,0xB4,0xD5,0x4A,
				0x3F,0xB4,0xB4,0xDA,0x3F,0xB4,0x94,0x68,
				0x3F,0xB4,0x73,0xF5,0x3F,0xB4,0x53,0x81,
				0x3F,0xB4,0x33,0x0C,0x3F,0xB4,0x12,0x95,
				0x3F,0xB3,0xF2,0x1D,0x3F,0xB3,0xD1,0xA3,
				0x3F,0xB3,0xB1,0x28,0x3F,0xB3,0x90,0xAC,
				0x3F,0xB3,0x70,0x2E,0x3F,0xB3,0x4F,0xAF,
				0x3F,0xB3,0x2F,0x2F,0x3F,0xB3,0x0E,0xAD,
				0x3F,0xB2,0xEE,0x29,0x3F,0xB2,0xCD,0xA4,
				0x3F,0xB2,0xAD,0x1E,0x3F,0xB2,0x8C,0x96,
				0x3F,0xB2,0x6C,0x0D,0x3F,0xB2,0x4B,0x82,
				0x3F,0xB2,0x2A,0xF6,0x3F,0xB2,0x0A,0x68,
				0x3F,0xB1,0xE9,0xD9,0x3F,0xB1,0xC9,0x49,
				0x3F,0xB1,0xA8,0xB6,0x3F,0xB1,0x88,0x23,
				0x3F,0xB1,0x67,0x8D,0x3F,0xB1,0x46,0xF6,
				0x3F,0xB1,0x26,0x5E,0x3F,0xB1,0x05,0xC4,
				0x3F,0xB0,0xE5,0x28,0x3F,0xB0,0xC4,0x8B,
				0x3F,0xB0,0xA3,0xED,0x3F,0xB0,0x83,0x4C,
				0x3F,0xB0,0x62,0xAA,0x3F,0xB0,0x42,0x07,
				0x3F,0xB0,0x21,0x61,0x3F,0xB0,0x00,0xBA,
				0x3F,0xAF,0xE0,0x12,0x3F,0xAF,0xBF,0x68,
				0x3F,0xAF,0x9E,0xBC,0x3F,0xAF,0x7E,0x0E,
				0x3F,0xAF,0x5D,0x5F,0x3F,0xAF,0x3C,0xAE,
				0x3F,0xAF,0x1B,0xFC,0x3F,0xAE,0xFB,0x47,
				0x3F,0xAE,0xDA,0x91,0x3F,0xAE,0xB9,0xD9,
				0x3F,0xAE,0x99,0x20,0x3F,0xAE,0x78,0x64,
				0x3F,0xAE,0x57,0xA7,0x3F,0xAE,0x36,0xE8,
				0x3F,0xAE,0x16,0x28,0x3F,0xAD,0xF5,0x65,
				0x3F,0xAD,0xD4,0xA1,0x3F,0xAD,0xB3,0xDB,
				0x3F,0xAD,0x93,0x13,0x3F,0xAD,0x72,0x4A,
				0x3F,0xAD,0x51,0x7E,0x3F,0xAD,0x30,0xB1,
				0x3F,0xAD,0x0F,0xE1,0x3F,0xAC,0xEF,0x10,
				0x3F,0xAC,0xCE,0x3D,0x3F,0xAC,0xAD,0x68,
				0x3F,0xAC,0x8C,0x92,0x3F,0xAC,0x6B,0xB9,
				0x3F,0xAC,0x4A,0xDE,0x3F,0xAC,0x2A,0x02,
				0x3F,0xAC,0x09,0x23,0x3F,0xAB,0xE8,0x43,
				0x3F,0xAB,0xC7,0x60,0x3F,0xAB,0xA6,0x7C,
				0x3F,0xAB,0x85,0x96,0x3F,0xAB,0x64,0xAD,
				0x3F,0xAB,0x43,0xC3,0x3F,0xAB,0x22,0xD7,
				0x3F,0xAB,0x01,0xE8,0x3F,0xAA,0xE0,0xF8,
				0x3F,0xAA,0xC0,0x06,0x3F,0xAA,0x9F,0x11,
				0x3F,0xAA,0x7E,0x1B,0x3F,0xAA,0x5D,0x22,
				0x3F,0xAA,0x3C,0x27,0x3F,0xAA,0x1B,0x2B,
				0x3F,0xA9,0xFA,0x2C,0x3F,0xA9,0xD9,0x2B,
				0x3F,0xA9,0xB8,0x28,0x3F,0xA9,0x97,0x23,
				0x3F,0xA9,0x76,0x1B,0x3F,0xA9,0x55,0x12,
				0x3F,0xA9,0x34,0x06,0x3F,0xA9,0x12,0xF8,
				0x3F,0xA8,0xF1,0xE8,0x3F,0xA8,0xD0,0xD6,
				0x3F,0xA8,0xAF,0xC2,0x3F,0xA8,0x8E,0xAB,
				0x3F,0xA8,0x6D,0x92,0x3F,0xA8,0x4C,0x77,
				0x3F,0xA8,0x2B,0x5A,0x3F,0xA8,0x0A,0x3A,
				0x3F,0xA7,0xE9,0x19,0x3F,0xA7,0xC7,0xF5,
				0x3F,0xA7,0xA6,0xCE,0x3F,0xA7,0x85,0xA6,
				0x3F,0xA7,0x64,0x7B,0x3F,0xA7,0x43,0x4D,
				0x3F,0xA7,0x22,0x1E,0x3F,0xA7,0x00,0xEC,
				0x3F,0xA6,0xDF,0xB8,0x3F,0xA6,0xBE,0x81,
				0x3F,0xA6,0x9D,0x48,0x3F,0xA6,0x7C,0x0D,
				0x3F,0xA6,0x5A,0xCF,0x3F,0xA6,0x39,0x8F,
				0x3F,0xA6,0x18,0x4C,0x3F,0xA5,0xF7,0x07,
				0x3F,0xA5,0xD5,0xC0,0x3F,0xA5,0xB4,0x76,
				0x3F,0xA5,0x93,0x29,0x3F,0xA5,0x71,0xDB,
				0x3F,0xA5,0x50,0x89,0x3F,0xA5,0x2F,0x36,
				0x3F,0xA5,0x0D,0xDF,0x3F,0xA4,0xEC,0x86,
				0x3F,0xA4,0xCB,0x2B,0x3F,0xA4,0xA9,0xCD,
				0x3F,0xA4,0x88,0x6D,0x3F,0xA4,0x67,0x0A,
				0x3F,0xA4,0x45,0xA5,0x3F,0xA4,0x24,0x3D,
				0x3F,0xA4,0x02,0xD2,0x3F,0xA3,0xE1,0x65,
				0x3F,0xA3,0xBF,0xF5,0x3F,0xA3,0x9E,0x82,
				0x3F,0xA3,0x7D,0x0D,0x3F,0xA3,0x5B,0x95,
				0x3F,0xA3,0x3A,0x1B,0x3F,0xA3,0x18,0x9E,
				0x3F,0xA2,0xF7,0x1E,0x3F,0xA2,0xD5,0x9C,
				0x3F,0xA2,0xB4,0x16,0x3F,0xA2,0x92,0x8F,
				0x3F,0xA2,0x71,0x04,0x3F,0xA2,0x4F,0x77,
				0x3F,0xA2,0x2D,0xE7,0x3F,0xA2,0x0C,0x54,
				0x3F,0xA1,0xEA,0xBE,0x3F,0xA1,0xC9,0x26,
				0x3F,0xA1,0xA7,0x8B,0x3F,0xA1,0x85,0xED,
				0x3F,0xA1,0x64,0x4C,0x3F,0xA1,0x42,0xA8,
				0x3F,0xA1,0x21,0x02,0x3F,0xA0,0xFF,0x58,
				0x3F,0xA0,0xDD,0xAC,0x3F,0xA0,0xBB,0xFD,
				0x3F,0xA0,0x9A,0x4B,0x3F,0xA0,0x78,0x96,
				0x3F,0xA0,0x56,0xDE,0x3F,0xA0,0x35,0x24,
				0x3F,0xA0,0x13,0x66,0x3F,0x9F,0xF1,0xA5,
				0x3F,0x9F,0xCF,0xE2,0x3F,0x9F,0xAE,0x1B,
				0x3F,0x9F,0x8C,0x52,0x3F,0x9F,0x6A,0x85,
				0x3F,0x9F,0x48,0xB6,0x3F,0x9F,0x26,0xE3,
				0x3F,0x9F,0x05,0x0E,0x3F,0x9E,0xE3,0x35,
				0x3F,0x9E,0xC1,0x59,0x3F,0x9E,0x9F,0x7A,
				0x3F,0x9E,0x7D,0x99,0x3F,0x9E,0x5B,0xB4,
				0x3F,0x9E,0x39,0xCC,0x3F,0x9E,0x17,0xE0,
				0x3F,0x9D,0xF5,0xF2,0x3F,0x9D,0xD4,0x01,
				0x3F,0x9D,0xB2,0x0C,0x3F,0x9D,0x90,0x14,
				0x3F,0x9D,0x6E,0x19,0x3F,0x9D,0x4C,0x1B,
				0x3F,0x9D,0x2A,0x19,0x3F,0x9D,0x08,0x15,
				0x3F,0x9C,0xE6,0x0D,0x3F,0x9C,0xC4,0x02,
				0x3F,0x9C,0xA1,0xF3,0x3F,0x9C,0x7F,0xE2,
				0x3F,0x9C,0x5D,0xCD,0x3F,0x9C,0x3B,0xB4,
				0x3F,0x9C,0x19,0x99,0x3F,0x9B,0xF7,0x7A,
				0x3F,0x9B,0xD5,0x57,0x3F,0x9B,0xB3,0x32,
				0x3F,0x9B,0x91,0x09,0x3F,0x9B,0x6E,0xDC,
				0x3F,0x9B,0x4C,0xAC,0x3F,0x9B,0x2A,0x79,
				0x3F,0x9B,0x08,0x43,0x3F,0x9A,0xE6,0x09,
				0x3F,0x9A,0xC3,0xCB,0x3F,0x9A,0xA1,0x8A,
				0x3F,0x9A,0x7F,0x46,0x3F,0x9A,0x5C,0xFE,
				0x3F,0x9A,0x3A,0xB2,0x3F,0x9A,0x18,0x63,
				0x3F,0x99,0xF6,0x11,0x3F,0x99,0xD3,0xBA,
				0x3F,0x99,0xB1,0x61,0x3F,0x99,0x8F,0x04,
				0x3F,0x99,0x6C,0xA3,0x3F,0x99,0x4A,0x3E,
				0x3F,0x99,0x27,0xD6,0x3F,0x99,0x05,0x6B,
				0x3F,0x98,0xE2,0xFB,0x3F,0x98,0xC0,0x88,
				0x3F,0x98,0x9E,0x12,0x3F,0x98,0x7B,0x97,
				0x3F,0x98,0x59,0x19,0x3F,0x98,0x36,0x97,
				0x3F,0x98,0x14,0x12,0x3F,0x97,0xF1,0x88,
				0x3F,0x97,0xCE,0xFB,0x3F,0x97,0xAC,0x6B,
				0x3F,0x97,0x89,0xD6,0x3F,0x97,0x67,0x3E,
				0x3F,0x97,0x44,0xA1,0x3F,0x97,0x22,0x01,
				0x3F,0x96,0xFF,0x5D,0x3F,0x96,0xDC,0xB6,
				0x3F,0x96,0xBA,0x0A,0x3F,0x96,0x97,0x5A,
				0x3F,0x96,0x74,0xA7,0x3F,0x96,0x51,0xEF,
				0x3F,0x96,0x2F,0x34,0x3F,0x96,0x0C,0x75,
				0x3F,0x95,0xE9,0xB1,0x3F,0x95,0xC6,0xEA,
				0x3F,0x95,0xA4,0x1F,0x3F,0x95,0x81,0x4F,
				0x3F,0x95,0x5E,0x7C,0x3F,0x95,0x3B,0xA5,
				0x3F,0x95,0x18,0xC9,0x3F,0x94,0xF5,0xEA,
				0x3F,0x94,0xD3,0x06,0x3F,0x94,0xB0,0x1E,
				0x3F,0x94,0x8D,0x32,0x3F,0x94,0x6A,0x42,
				0x3F,0x94,0x47,0x4E,0x3F,0x94,0x24,0x56,
				0x3F,0x94,0x01,0x59,0x3F,0x93,0xDE,0x59,
				0x3F,0x93,0xBB,0x54,0x3F,0x93,0x98,0x4A,
				0x3F,0x93,0x75,0x3D,0x3F,0x93,0x52,0x2B,
				0x3F,0x93,0x2F,0x15,0x3F,0x93,0x0B,0xFB,
				0x3F,0x92,0xE8,0xDC,0x3F,0x92,0xC5,0xB9,
				0x3F,0x92,0xA2,0x91,0x3F,0x92,0x7F,0x66,
				0x3F,0x92,0x5C,0x36,0x3F,0x92,0x39,0x01,
				0x3F,0x92,0x15,0xC8,0x3F,0x91,0xF2,0x8B,
				0x3F,0x91,0xCF,0x49,0x3F,0x91,0xAC,0x02,
				0x3F,0x91,0x88,0xB7,0x3F,0x91,0x65,0x68,
				0x3F,0x91,0x42,0x14,0x3F,0x91,0x1E,0xBC,
				0x3F,0x90,0xFB,0x5F,0x3F,0x90,0xD7,0xFD,
				0x3F,0x90,0xB4,0x97,0x3F,0x90,0x91,0x2C,
				0x3F,0x90,0x6D,0xBD,0x3F,0x90,0x4A,0x49,
				0x3F,0x90,0x26,0xD0,0x3F,0x90,0x03,0x52,
				0x3F,0x8F,0xDF,0xD0,0x3F,0x8F,0xBC,0x49,
				0x3F,0x8F,0x98,0xBE,0x3F,0x8F,0x75,0x2D,
				0x3F,0x8F,0x51,0x98,0x3F,0x8F,0x2D,0xFE,
				0x3F,0x8F,0x0A,0x60,0x3F,0x8E,0xE6,0xBC,
				0x3F,0x8E,0xC3,0x14,0x3F,0x8E,0x9F,0x66,
				0x3F,0x8E,0x7B,0xB4,0x3F,0x8E,0x57,0xFD,
				0x3F,0x8E,0x34,0x41,0x3F,0x8E,0x10,0x80,
				0x3F,0x8D,0xEC,0xBA,0x3F,0x8D,0xC8,0xEF,
				0x3F,0x8D,0xA5,0x20,0x3F,0x8D,0x81,0x4B,
				0x3F,0x8D,0x5D,0x71,0x3F,0x8D,0x39,0x92,
				0x3F,0x8D,0x15,0xAE,0x3F,0x8C,0xF1,0xC4,
				0x3F,0x8C,0xCD,0xD6,0x3F,0x8C,0xA9,0xE3,
				0x3F,0x8C,0x85,0xEA,0x3F,0x8C,0x61,0xEC,
				0x3F,0x8C,0x3D,0xE9,0x3F,0x8C,0x19,0xE1,
				0x3F,0x8B,0xF5,0xD4,0x3F,0x8B,0xD1,0xC1,
				0x3F,0x8B,0xAD,0xA9,0x3F,0x8B,0x89,0x8C,
				0x3F,0x8B,0x65,0x69,0x3F,0x8B,0x41,0x41,
				0x3F,0x8B,0x1D,0x14,0x3F,0x8A,0xF8,0xE2,
				0x3F,0x8A,0xD4,0xAA,0x3F,0x8A,0xB0,0x6C,
				0x3F,0x8A,0x8C,0x29,0x3F,0x8A,0x67,0xE1,
				0x3F,0x8A,0x43,0x93,0x3F,0x8A,0x1F,0x40,
				0x3F,0x89,0xFA,0xE7,0x3F,0x89,0xD6,0x88,
				0x3F,0x89,0xB2,0x25,0x3F,0x89,0x8D,0xBB,
				0x3F,0x89,0x69,0x4C,0x3F,0x89,0x44,0xD7,
				0x3F,0x89,0x20,0x5D,0x3F,0x88,0xFB,0xDC,
				0x3F,0x88,0xD7,0x57,0x3F,0x88,0xB2,0xCB,
				0x3F,0x88,0x8E,0x3A,0x3F,0x88,0x69,0xA3,
				0x3F,0x88,0x45,0x06,0x3F,0x88,0x20,0x63,
				0x3F,0x87,0xFB,0xBB,0x3F,0x87,0xD7,0x0C,
				0x3F,0x87,0xB2,0x58,0x3F,0x87,0x8D,0x9E,
				0x3F,0x87,0x68,0xDE,0x3F,0x87,0x44,0x18,
				0x3F,0x87,0x1F,0x4C,0x3F,0x86,0xFA,0x7A,
				0x3F,0x86,0xD5,0xA2,0x3F,0x86,0xB0,0xC4,
				0x3F,0x86,0x8B,0xE0,0x3F,0x86,0x66,0xF6,
				0x3F,0x86,0x42,0x06,0x3F,0x86,0x1D,0x0F,
				0x3F,0x85,0xF8,0x13,0x3F,0x85,0xD3,0x10,
				0x3F,0x85,0xAE,0x07,0x3F,0x85,0x88,0xF8,
				0x3F,0x85,0x63,0xE2,0x3F,0x85,0x3E,0xC7,
				0x3F,0x85,0x19,0xA5,0x3F,0x84,0xF4,0x7C,
				0x3F,0x84,0xCF,0x4E,0x3F,0x84,0xAA,0x19,
				0x3F,0x84,0x84,0xDD,0x3F,0x84,0x5F,0x9B,
				0x3F,0x84,0x3A,0x53,0x3F,0x84,0x15,0x04,
				0x3F,0x83,0xEF,0xAF,0x3F,0x83,0xCA,0x53,
				0x3F,0x83,0xA4,0xF0,0x3F,0x83,0x7F,0x87,
				0x3F,0x83,0x5A,0x18,0x3F,0x83,0x34,0xA1,
				0x3F,0x83,0x0F,0x24,0x3F,0x82,0xE9,0xA1,
				0x3F,0x82,0xC4,0x16,0x3F,0x82,0x9E,0x85,
				0x3F,0x82,0x78,0xED,0x3F,0x82,0x53,0x4F,
				0x3F,0x82,0x2D,0xA9,0x3F,0x82,0x07,0xFD,
				0x3F,0x81,0xE2,0x4A,0x3F,0x81,0xBC,0x90,
				0x3F,0x81,0x96,0xCF,0x3F,0x81,0x71,0x07,
				0x3F,0x81,0x4B,0x38,0x3F,0x81,0x25,0x62,
				0x3F,0x80,0xFF,0x85,0x3F,0x80,0xD9,0xA0,
				0x3F,0x80,0xB3,0xB5,0x3F,0x80,0x8D,0xC3,
				0x3F,0x80,0x67,0xC9,0x3F,0x80,0x41,0xC9,
				0x3F,0x80,0x1B,0xC1,0x3F,0x7F,0xEB,0x63,
				0x3F,0x7F,0x9F,0x36,0x3F,0x7F,0x52,0xFA,
				0x3F,0x7F,0x06,0xB0,0x3F,0x7E,0xBA,0x57,
				0x3F,0x7E,0x6D,0xEF,0x3F,0x7E,0x21,0x79,
				0x3F,0x7D,0xD4,0xF3,0x3F,0x7D,0x88,0x5F,
				0x3F,0x7D,0x3B,0xBB,0x3F,0x7C,0xEF,0x09,
				0x3F,0x7C,0xA2,0x47,0x3F,0x7C,0x55,0x76,
				0x3F,0x7C,0x08,0x96,0x3F,0x7B,0xBB,0xA6,
				0x3F,0x7B,0x6E,0xA7,0x3F,0x7B,0x21,0x99,
				0x3F,0x7A,0xD4,0x7B,0x3F,0x7A,0x87,0x4D,
				0x3F,0x7A,0x3A,0x10,0x3F,0x79,0xEC,0xC3,
				0x3F,0x79,0x9F,0x66,0x3F,0x79,0x51,0xF9,
				0x3F,0x79,0x04,0x7D,0x3F,0x78,0xB6,0xF0,
				0x3F,0x78,0x69,0x53,0x3F,0x78,0x1B,0xA7,
				0x3F,0x77,0xCD,0xEA,0x3F,0x77,0x80,0x1D,
				0x3F,0x77,0x32,0x3F,0x3F,0x76,0xE4,0x51,
				0x3F,0x76,0x96,0x53,0x3F,0x76,0x48,0x44,
				0x3F,0x75,0xFA,0x24,0x3F,0x75,0xAB,0xF4,
				0x3F,0x75,0x5D,0xB3,0x3F,0x75,0x0F,0x61,
				0x3F,0x74,0xC0,0xFE,0x3F,0x74,0x72,0x8B,
				0x3F,0x74,0x24,0x06,0x3F,0x73,0xD5,0x70,
				0x3F,0x73,0x86,0xC9,0x3F,0x73,0x38,0x11,
				0x3F,0x72,0xE9,0x48,0x3F,0x72,0x9A,0x6D,
				0x3F,0x72,0x4B,0x80,0x3F,0x71,0xFC,0x82,
				0x3F,0x71,0xAD,0x73,0x3F,0x71,0x5E,0x52,
				0x3F,0x71,0x0F,0x1F,0x3F,0x70,0xBF,0xDA,
				0x3F,0x70,0x70,0x83,0x3F,0x70,0x21,0x1A,
				0x3F,0x6F,0xD1,0x9F,0x3F,0x6F,0x82,0x12,
				0x3F,0x6F,0x32,0x73,0x3F,0x6E,0xE2,0xC1,
				0x3F,0x6E,0x92,0xFD,0x3F,0x6E,0x43,0x27,
				0x3F,0x6D,0xF3,0x3E,0x3F,0x6D,0xA3,0x42,
				0x3F,0x6D,0x53,0x34,0x3F,0x6D,0x03,0x13,
				0x3F,0x6C,0xB2,0xDF,0x3F,0x6C,0x62,0x97,
				0x3F,0x6C,0x12,0x3D,0x3F,0x6B,0xC1,0xD0,
				0x3F,0x6B,0x71,0x50,0x3F,0x6B,0x20,0xBC,
				0x3F,0x6A,0xD0,0x15,0x3F,0x6A,0x7F,0x5A,
				0x3F,0x6A,0x2E,0x8C,0x3F,0x69,0xDD,0xAA,
				0x3F,0x69,0x8C,0xB4,0x3F,0x69,0x3B,0xAB,
				0x3F,0x68,0xEA,0x8E,0x3F,0x68,0x99,0x5C,
				0x3F,0x68,0x48,0x17,0x3F,0x67,0xF6,0xBD,
				0x3F,0x67,0xA5,0x4F,0x3F,0x67,0x53,0xCD,
				0x3F,0x67,0x02,0x36,0x3F,0x66,0xB0,0x8B,
				0x3F,0x66,0x5E,0xCB,0x3F,0x66,0x0C,0xF7,
				0x3F,0x65,0xBB,0x0D,0x3F,0x65,0x69,0x0F,
				0x3F,0x65,0x16,0xFB,0x3F,0x64,0xC4,0xD2,
				0x3F,0x64,0x72,0x95,0x3F,0x64,0x20,0x42,
				0x3F,0x63,0xCD,0xD9,0x3F,0x63,0x7B,0x5B,
				0x3F,0x63,0x28,0xC7,0x3F,0x62,0xD6,0x1E,
				0x3F,0x62,0x83,0x5F,0x3F,0x62,0x30,0x8A,
				0x3F,0x61,0xDD,0x9E,0x3F,0x61,0x8A,0x9D,
				0x3F,0x61,0x37,0x86,0x3F,0x60,0xE4,0x58,
				0x3F,0x60,0x91,0x14,0x3F,0x60,0x3D,0xB9,
				0x3F,0x5F,0xEA,0x47,0x3F,0x5F,0x96,0xBF,
				0x3F,0x5F,0x43,0x20,0x3F,0x5E,0xEF,0x6A,
				0x3F,0x5E,0x9B,0x9D,0x3F,0x5E,0x47,0xB9,
				0x3F,0x5D,0xF3,0xBD,0x3F,0x5D,0x9F,0xAA,
				0x3F,0x5D,0x4B,0x7F,0x3F,0x5C,0xF7,0x3D,
				0x3F,0x5C,0xA2,0xE3,0x3F,0x5C,0x4E,0x72,
				0x3F,0x5B,0xF9,0xE8,0x3F,0x5B,0xA5,0x46,
				0x3F,0x5B,0x50,0x8C,0x3F,0x5A,0xFB,0xB9,
				0x3F,0x5A,0xA6,0xCF,0x3F,0x5A,0x51,0xCB,
				0x3F,0x59,0xFC,0xAF,0x3F,0x59,0xA7,0x7A,
				0x3F,0x59,0x52,0x2C,0x3F,0x58,0xFC,0xC5,
				0x3F,0x58,0xA7,0x45,0x3F,0x58,0x51,0xAC,
				0x3F,0x57,0xFB,0xF9,0x3F,0x57,0xA6,0x2D,
				0x3F,0x57,0x50,0x47,0x3F,0x56,0xFA,0x47,
				0x3F,0x56,0xA4,0x2D,0x3F,0x56,0x4D,0xF9,
				0x3F,0x55,0xF7,0xAB,0x3F,0x55,0xA1,0x43,
				0x3F,0x55,0x4A,0xC0,0x3F,0x54,0xF4,0x22,
				0x3F,0x54,0x9D,0x6A,0x3F,0x54,0x46,0x97,
				0x3F,0x53,0xEF,0xA9,0x3F,0x53,0x98,0xA0,
				0x3F,0x53,0x41,0x7B,0x3F,0x52,0xEA,0x3B,
				0x3F,0x52,0x92,0xE0,0x3F,0x52,0x3B,0x69,
				0x3F,0x51,0xE3,0xD6,0x3F,0x51,0x8C,0x27,
				0x3F,0x51,0x34,0x5C,0x3F,0x50,0xDC,0x74,
				0x3F,0x50,0x84,0x70,0x3F,0x50,0x2C,0x50,
				0x3F,0x4F,0xD4,0x12,0x3F,0x4F,0x7B,0xB8,
				0x3F,0x4F,0x23,0x41,0x3F,0x4E,0xCA,0xAD,
				0x3F,0x4E,0x71,0xFB,0x3F,0x4E,0x19,0x2C,
				0x3F,0x4D,0xC0,0x3F,0x3F,0x4D,0x67,0x34,
				0x3F,0x4D,0x0E,0x0C,0x3F,0x4C,0xB4,0xC5,
				0x3F,0x4C,0x5B,0x60,0x3F,0x4C,0x01,0xDC,
				0x3F,0x4B,0xA8,0x3A,0x3F,0x4B,0x4E,0x79,
				0x3F,0x4A,0xF4,0x99,0x3F,0x4A,0x9A,0x9A,
				0x3F,0x4A,0x40,0x7C,0x3F,0x49,0xE6,0x3E,
				0x3F,0x49,0x8B,0xE1,0x3F,0x49,0x31,0x63,
				0x3F,0x48,0xD6,0xC6,0x3F,0x48,0x7C,0x09,
				0x3F,0x48,0x21,0x2B,0x3F,0x47,0xC6,0x2C,
				0x3F,0x47,0x6B,0x0D,0x3F,0x47,0x0F,0xCD,
				0x3F,0x46,0xB4,0x6C,0x3F,0x46,0x58,0xEA,
				0x3F,0x45,0xFD,0x46,0x3F,0x45,0xA1,0x81,
				0x3F,0x45,0x45,0x9A,0x3F,0x44,0xE9,0x90,
				0x3F,0x44,0x8D,0x65,0x3F,0x44,0x31,0x17,
				0x3F,0x43,0xD4,0xA6,0x3F,0x43,0x78,0x13,
				0x3F,0x43,0x1B,0x5C,0x3F,0x42,0xBE,0x83,
				0x3F,0x42,0x61,0x85,0x3F,0x42,0x04,0x65,
				0x3F,0x41,0xA7,0x20,0x3F,0x41,0x49,0xB8,
				0x3F,0x40,0xEC,0x2B,0x3F,0x40,0x8E,0x79,
				0x3F,0x40,0x30,0xA3,0x3F,0x3F,0xD2,0xA8,
				0x3F,0x3F,0x74,0x88,0x3F,0x3F,0x16,0x42,
				0x3F,0x3E,0xB7,0xD7,0x3F,0x3E,0x59,0x46,
				0x3F,0x3D,0xFA,0x8F,0x3F,0x3D,0x9B,0xB2,
				0x3F,0x3D,0x3C,0xAE,0x3F,0x3C,0xDD,0x84,
				0x3F,0x3C,0x7E,0x32,0x3F,0x3C,0x1E,0xB9,
				0x3F,0x3B,0xBF,0x19,0x3F,0x3B,0x5F,0x51,
				0x3F,0x3A,0xFF,0x61,0x3F,0x3A,0x9F,0x49,
				0x3F,0x3A,0x3F,0x09,0x3F,0x39,0xDE,0xA0,
				0x3F,0x39,0x7E,0x0D,0x3F,0x39,0x1D,0x52,
				0x3F,0x38,0xBC,0x6D,0x3F,0x38,0x5B,0x5E,
				0x3F,0x37,0xFA,0x26,0x3F,0x37,0x98,0xC3,
				0x3F,0x37,0x37,0x35,0x3F,0x36,0xD5,0x7D,
				0x3F,0x36,0x73,0x9A,0x3F,0x36,0x11,0x8B,
				0x3F,0x35,0xAF,0x50,0x3F,0x35,0x4C,0xEA,
				0x3F,0x34,0xEA,0x57,0x3F,0x34,0x87,0x98,
				0x3F,0x34,0x24,0xAC,0x3F,0x33,0xC1,0x93,
				0x3F,0x33,0x5E,0x4C,0x3F,0x32,0xFA,0xD8,
				0x3F,0x32,0x97,0x35,0x3F,0x32,0x33,0x65,
				0x3F,0x31,0xCF,0x65,0x3F,0x31,0x6B,0x37,
				0x3F,0x31,0x06,0xD9,0x3F,0x30,0xA2,0x4C,
				0x3F,0x30,0x3D,0x8F,0x3F,0x2F,0xD8,0xA2,
				0x3F,0x2F,0x73,0x83,0x3F,0x2F,0x0E,0x34,
				0x3F,0x2E,0xA8,0xB4,0x3F,0x2E,0x43,0x02,
				0x3F,0x2D,0xDD,0x1E,0x3F,0x2D,0x77,0x08,
				0x3F,0x2D,0x10,0xBF,0x3F,0x2C,0xAA,0x43,
				0x3F,0x2C,0x43,0x94,0x3F,0x2B,0xDC,0xB1,
				0x3F,0x2B,0x75,0x99,0x3F,0x2B,0x0E,0x4D,
				0x3F,0x2A,0xA6,0xCD,0x3F,0x2A,0x3F,0x16,
				0x3F,0x29,0xD7,0x2B,0x3F,0x29,0x6F,0x09,
				0x3F,0x29,0x06,0xB1,0x3F,0x28,0x9E,0x21,
				0x3F,0x28,0x35,0x5B,0x3F,0x27,0xCC,0x5D,
				0x3F,0x27,0x63,0x26,0x3F,0x26,0xF9,0xB7,
				0x3F,0x26,0x90,0x10,0x3F,0x26,0x26,0x2E,
				0x3F,0x25,0xBC,0x13,0x3F,0x25,0x51,0xBE,
				0x3F,0x24,0xE7,0x2E,0x3F,0x24,0x7C,0x62,
				0x3F,0x24,0x11,0x5B,0x3F,0x23,0xA6,0x18,
				0x3F,0x23,0x3A,0x99,0x3F,0x22,0xCE,0xDC,
				0x3F,0x22,0x62,0xE2,0x3F,0x21,0xF6,0xA9,
				0x3F,0x21,0x8A,0x32,0x3F,0x21,0x1D,0x7C,
				0x3F,0x20,0xB0,0x87,0x3F,0x20,0x43,0x52,
				0x3F,0x1F,0xD5,0xDB,0x3F,0x1F,0x68,0x24,
				0x3F,0x1E,0xFA,0x2B,0x3F,0x1E,0x8B,0xF0,
				0x3F,0x1E,0x1D,0x73,0x3F,0x1D,0xAE,0xB1,
				0x3F,0x1D,0x3F,0xAD,0x3F,0x1C,0xD0,0x63,
				0x3F,0x1C,0x60,0xD5,0x3F,0x1B,0xF1,0x01,
				0x3F,0x1B,0x80,0xE7,0x3F,0x1B,0x10,0x86,
				0x3F,0x1A,0x9F,0xDD,0x3F,0x1A,0x2E,0xED,
				0x3F,0x19,0xBD,0xB4,0x3F,0x19,0x4C,0x32,
				0x3F,0x18,0xDA,0x65,0x3F,0x18,0x68,0x4E,
				0x3F,0x17,0xF5,0xEC,0x3F,0x17,0x83,0x3E,
				0x3F,0x17,0x10,0x43,0x3F,0x16,0x9C,0xFB,
				0x3F,0x16,0x29,0x65,0x3F,0x15,0xB5,0x81,
				0x3F,0x15,0x41,0x4C,0x3F,0x14,0xCC,0xC8,
				0x3F,0x14,0x57,0xF3,0x3F,0x13,0xE2,0xCB,
				0x3F,0x13,0x6D,0x52,0x3F,0x12,0xF7,0x85,
				0x3F,0x12,0x81,0x64,0x3F,0x12,0x0A,0xEF,
				0x3F,0x11,0x94,0x23,0x3F,0x11,0x1D,0x01,
				0x3F,0x10,0xA5,0x88,0x3F,0x10,0x2D,0xB7,
				0x3F,0x0F,0xB5,0x8C,0x3F,0x0F,0x3D,0x08,
				0x3F,0x0E,0xC4,0x28,0x3F,0x0E,0x4A,0xED,
				0x3F,0x0D,0xD1,0x56,0x3F,0x0D,0x57,0x60,
				0x3F,0x0C,0xDD,0x0C,0x3F,0x0C,0x62,0x58,
				0x3F,0x0B,0xE7,0x44,0x3F,0x0B,0x6B,0xCE,
				0x3F,0x0A,0xEF,0xF6,0x3F,0x0A,0x73,0xBA,
				0x3F,0x09,0xF7,0x19,0x3F,0x09,0x7A,0x13,
				0x3F,0x08,0xFC,0xA5,0x3F,0x08,0x7E,0xD0,
				0x3F,0x08,0x00,0x91,0x3F,0x07,0x81,0xE9,
				0x3F,0x07,0x02,0xD4,0x3F,0x06,0x83,0x53,
				0x3F,0x06,0x03,0x64,0x3F,0x05,0x83,0x06,
				0x3F,0x05,0x02,0x38,0x3F,0x04,0x80,0xF8,
				0x3F,0x03,0xFF,0x45,0x3F,0x03,0x7D,0x1D,
				0x3F,0x02,0xFA,0x80,0x3F,0x02,0x77,0x6C,
				0x3F,0x01,0xF3,0xDF,0x3F,0x01,0x6F,0xD8,
				0x3F,0x00,0xEB,0x56,0x3F,0x00,0x66,0x56,
				0x3E,0xFF,0xC1,0xB2,0x3E,0xFE,0xB5,0xB6,
				0x3E,0xFD,0xA8,0xB7,0x3E,0xFC,0x9A,0xB2,
				0x3E,0xFB,0x8B,0xA3,0x3E,0xFA,0x7B,0x87,
				0x3E,0xF9,0x6A,0x5A,0x3E,0xF8,0x58,0x19,
				0x3E,0xF7,0x44,0xBF,0x3E,0xF6,0x30,0x4B,
				0x3E,0xF5,0x1A,0xB7,0x3E,0xF4,0x04,0x00,
				0x3E,0xF2,0xEC,0x21,0x3E,0xF1,0xD3,0x18,
				0x3E,0xF0,0xB8,0xE0,0x3E,0xEF,0x9D,0x74,
				0x3E,0xEE,0x80,0xD0,0x3E,0xED,0x62,0xF0,
				0x3E,0xEC,0x43,0xD0,0x3E,0xEB,0x23,0x6A,
				0x3E,0xEA,0x01,0xBA,0x3E,0xE8,0xDE,0xBC,
				0x3E,0xE7,0xBA,0x69,0x3E,0xE6,0x94,0xBE,
				0x3E,0xE5,0x6D,0xB5,0x3E,0xE4,0x45,0x49,
				0x3E,0xE3,0x1B,0x74,0x3E,0xE1,0xF0,0x30,
				0x3E,0xE0,0xC3,0x78,0x3E,0xDF,0x95,0x47,
				0x3E,0xDE,0x65,0x95,0x3E,0xDD,0x34,0x5D,
				0x3E,0xDC,0x01,0x98,0x3E,0xDA,0xCD,0x40,
				0x3E,0xD9,0x97,0x4F,0x3E,0xD8,0x5F,0xBC,
				0x3E,0xD7,0x26,0x82,0x3E,0xD5,0xEB,0x99,
				0x3E,0xD4,0xAE,0xF9,0x3E,0xD3,0x70,0x9A,
				0x3E,0xD2,0x30,0x75,0x3E,0xD0,0xEE,0x82,
				0x3E,0xCF,0xAA,0xB8,0x3E,0xCE,0x65,0x0E,
				0x3E,0xCD,0x1D,0x7B,0x3E,0xCB,0xD3,0xF7,
				0x3E,0xCA,0x88,0x77,0x3E,0xC9,0x3A,0xF3,
				0x3E,0xC7,0xEB,0x5F,0x3E,0xC6,0x99,0xB1,
				0x3E,0xC5,0x45,0xDF,0x3E,0xC3,0xEF,0xDD,
				0x3E,0xC2,0x97,0x9F,0x3E,0xC1,0x3D,0x1B,
				0x3E,0xBF,0xE0,0x43,0x3E,0xBE,0x81,0x0B,
				0x3E,0xBD,0x1F,0x65,0x3E,0xBB,0xBB,0x43,
				0x3E,0xBA,0x54,0x98,0x3E,0xB8,0xEB,0x55,
				0x3E,0xB7,0x7F,0x69,0x3E,0xB6,0x10,0xC6,
				0x3E,0xB4,0x9F,0x5B,0x3E,0xB3,0x2B,0x16,
				0x3E,0xB1,0xB3,0xE5,0x3E,0xB0,0x39,0xB7,
				0x3E,0xAE,0xBC,0x77,0x3E,0xAD,0x3C,0x10,
				0x3E,0xAB,0xB8,0x6F,0x3E,0xAA,0x31,0x7D,
				0x3E,0xA8,0xA7,0x22,0x3E,0xA7,0x19,0x47,
				0x3E,0xA5,0x87,0xD2,0x3E,0xA3,0xF2,0xA9,
				0x3E,0xA2,0x59,0xB0,0x3E,0xA0,0xBC,0xCA,
				0x3E,0x9F,0x1B,0xD8,0x3E,0x9D,0x76,0xBA,
				0x3E,0x9B,0xCD,0x4F,0x3E,0x9A,0x1F,0x73,
				0x3E,0x98,0x6C,0xFF,0x3E,0x96,0xB5,0xCD,
				0x3E,0x94,0xF9,0xB2,0x3E,0x93,0x38,0x82,
				0x3E,0x91,0x72,0x0D,0x3E,0x8F,0xA6,0x22,
				0x3E,0x8D,0xD4,0x8C,0x3E,0x8B,0xFD,0x12,
				0x3E,0x8A,0x1F,0x77,0x3E,0x88,0x3B,0x7C,
				0x3E,0x86,0x50,0xDB,0x3E,0x84,0x5F,0x49,
				0x3E,0x82,0x66,0x79,0x3E,0x80,0x66,0x14,
				0x3E,0x7C,0xBB,0x7B,0x3E,0x78,0x9A,0x25,
				0x3E,0x74,0x67,0x4D,0x3E,0x70,0x22,0x08,
				0x3E,0x6B,0xC9,0x56,0x3E,0x67,0x5C,0x1D,
				0x3E,0x62,0xD9,0x2C,0x3E,0x5E,0x3F,0x2E,
				0x3E,0x59,0x8C,0xAD,0x3E,0x54,0xC0,0x0A,
				0x3E,0x4F,0xD7,0x75,0x3E,0x4A,0xD0,0xE6,
				0x3E,0x45,0xAA,0x15,0x3E,0x40,0x60,0x69,
				0x3E,0x3A,0xF0,0xEE,0x3E,0x35,0x58,0x3C,
				0x3E,0x2F,0x92,0x64,0x3E,0x29,0x9A,0xC9,
				0x3E,0x23,0x6B,0xF6,0x3E,0x1C,0xFF,0x67,
				0x3E,0x16,0x4D,0x31,0x3E,0x0F,0x4B,0x90,
				0x3E,0x07,0xEE,0x3D,0x3E,0x00,0x25,0x6A,
				0x3D,0xEF,0xB8,0x4C,0x3D,0xDD,0xEB,0x5D,
				0x3D,0xCA,0x91,0x36,0x3D,0xB5,0x2A,0xB7,
				0x3D,0x9C,0xE1,0xDE,0x3D,0x80,0x15,0x5B,
				0x3D,0x35,0x1F,0x5F,0x00,0x00,0x00,0x00
			};

	//ASSERT((x >= -1) && (x <= 1));

/*
	if (x < 0)
		return ANGLE_PI - ((float*)act)[(int) (-x*1023)];
	else
		return ((float*)act)[(int) (x*1023)];
*/

	if (x < 0)
	{
		absX = x * -1023;
		negative = TRUE;
	}
	else
	{
		absX = x * 1023;
		negative = FALSE;
	}

	intAbsX = (int) absX;

	if (intAbsX < 1023)
	{
		fraction = absX - intAbsX;

		xVal	 = ((float*)act)[intAbsX];
		xP1Val = ((float*)act)[intAbsX + 1];

		blendVal = BlendFLOAT(fraction, xVal, xP1Val);

		if (negative)
			return ANGLE_PI - blendVal;
		else
			return blendVal;
	}
	else
	{
		if (negative)
			return ANGLE_PI - ((float*)act)[1023];
		else
			return ((float*)act)[1023];
	}
}







/*****************************************************************************
*
*
*
*					Optimised matrix functions by S.Broumley
*
*
*
*****************************************************************************/

#define MATRIX_SET_LAST_COLUMN		\
	mfThis[0][3] =							\
	mfThis[1][3] = 						\
	mfThis[2][3] = 0 ;					\
	mfThis[3][3] = 1 ;



void CMtxF__PostMult(CMtxF mfThis, CMtxF mfLeft, CMtxF mfRight)
{
	mfThis[0][0] = (mfLeft[0][0] * mfRight[0][0]) + (mfLeft[0][1] * mfRight[1][0]) + (mfLeft[0][2] * mfRight[2][0]) ;
	mfThis[0][1] = (mfLeft[0][0] * mfRight[0][1]) + (mfLeft[0][1] * mfRight[1][1]) + (mfLeft[0][2] * mfRight[2][1]) ;
	mfThis[0][2] = (mfLeft[0][0] * mfRight[0][2]) + (mfLeft[0][1] * mfRight[1][2]) + (mfLeft[0][2] * mfRight[2][2]) ;

	mfThis[1][0] = (mfLeft[1][0] * mfRight[0][0]) + (mfLeft[1][1] * mfRight[1][0]) + (mfLeft[1][2] * mfRight[2][0]) ;
	mfThis[1][1] = (mfLeft[1][0] * mfRight[0][1]) + (mfLeft[1][1] * mfRight[1][1]) + (mfLeft[1][2] * mfRight[2][1]) ;
	mfThis[1][2] = (mfLeft[1][0] * mfRight[0][2]) + (mfLeft[1][1] * mfRight[1][2]) + (mfLeft[1][2] * mfRight[2][2]) ;

	mfThis[2][0] = (mfLeft[2][0] * mfRight[0][0]) + (mfLeft[2][1] * mfRight[1][0]) + (mfLeft[2][2] * mfRight[2][0]) ;
	mfThis[2][1] = (mfLeft[2][0] * mfRight[0][1]) + (mfLeft[2][1] * mfRight[1][1]) + (mfLeft[2][2] * mfRight[2][1]) ;
	mfThis[2][2] = (mfLeft[2][0] * mfRight[0][2]) + (mfLeft[2][1] * mfRight[1][2]) + (mfLeft[2][2] * mfRight[2][2]) ;

	mfThis[3][0] = (mfLeft[3][0] * mfRight[0][0]) + (mfLeft[3][1] * mfRight[1][0]) + (mfLeft[3][2] * mfRight[2][0]) + mfRight[3][0] ;
	mfThis[3][1] = (mfLeft[3][0] * mfRight[0][1]) + (mfLeft[3][1] * mfRight[1][1]) + (mfLeft[3][2] * mfRight[2][1]) + mfRight[3][1] ;
	mfThis[3][2] = (mfLeft[3][0] * mfRight[0][2]) + (mfLeft[3][1] * mfRight[1][2]) + (mfLeft[3][2] * mfRight[2][2]) + mfRight[3][2] ;

	MATRIX_SET_LAST_COLUMN
	// Total Adds 27, Total Multiplies 36 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PreMultTranslate(CMtxF mfThis, FLOAT Tx, FLOAT Ty, FLOAT Tz)
{
	mfThis[3][0] += (Tx * mfThis[0][0]) + (Ty * mfThis[1][0]) + (Tz * mfThis[2][0]) ;
	mfThis[3][1] += (Tx * mfThis[0][1]) + (Ty * mfThis[1][1]) + (Tz * mfThis[2][1]) ;
	mfThis[3][2] += (Tx * mfThis[0][2]) + (Ty * mfThis[1][2]) + (Tz * mfThis[2][2]) ;

	// Total Adds 9, Total Multiplies 9 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PostMultTranslate(CMtxF mfThis, FLOAT Tx, FLOAT Ty, FLOAT Tz)
{
	mfThis[3][0] += Tx ;
	mfThis[3][1] += Ty ;
	mfThis[3][2] += Tz ;

	// Total Adds 3, Total Multiplies 0 (Assumes column 4 = {0,0,0,1})
}



void CMtxF__PreMultScale(CMtxF mfThis, FLOAT Sx, FLOAT Sy, FLOAT Sz)
{
	mfThis[0][0] *= Sx ;
	mfThis[0][1] *= Sx ;
	mfThis[0][2] *= Sx ;

	mfThis[1][0] *= Sy ;
	mfThis[1][1] *= Sy ;
	mfThis[1][2] *= Sy ;

	mfThis[2][0] *= Sz ;
	mfThis[2][1] *= Sz ;
	mfThis[2][2] *= Sz ;

	// Total Adds 0, Total Multiplies 9 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__CopyPreMultScale(CMtxF mfThis, CMtxF mfSource, FLOAT Sx, FLOAT Sy, FLOAT Sz)
{
	mfThis[0][0] = mfSource[0][0] * Sx ;
	mfThis[0][1] = mfSource[0][1] * Sx ;
	mfThis[0][2] = mfSource[0][2] * Sx ;

	mfThis[1][0] = mfSource[1][0] * Sy ;
	mfThis[1][1] = mfSource[1][1] * Sy ;
	mfThis[1][2] = mfSource[1][2] * Sy ;

	mfThis[2][0] = mfSource[2][0] * Sz ;
	mfThis[2][1] = mfSource[2][1] * Sz ;
	mfThis[2][2] = mfSource[2][2] * Sz ;

	mfThis[3][0] = mfSource[3][0] ;
	mfThis[3][1] = mfSource[3][1] ;
	mfThis[3][2] = mfSource[3][2] ;

	MATRIX_SET_LAST_COLUMN

	// Total Adds 0, Total Multiplies 9 (Assumes column 4 = {0,0,0,1})
}



void CMtxF__PostMultScale(CMtxF mfThis, FLOAT Sx, FLOAT Sy, FLOAT Sz)
{
	mfThis[0][0] *= Sx ;
	mfThis[0][1] *= Sy ;
	mfThis[0][2] *= Sz ;

	mfThis[1][0] *= Sx ;
	mfThis[1][1] *= Sy ;
	mfThis[1][2] *= Sz ;

	mfThis[2][0] *= Sx ;
	mfThis[2][1] *= Sy ;
	mfThis[2][2] *= Sz ;

	mfThis[3][0] *= Sx ;
	mfThis[3][1] *= Sy ;
	mfThis[3][2] *= Sz ;

	// Total Adds 0, Total Multiplies 12 (Assumes column 4 = {0,0,0,1})
}



void CMtxF__RotateX(CMtxF mfThis, float Theta)
{
	float	sine ;
	float	cosine ;

	sine = sin(Theta) ;
	cosine = cos(Theta) ;

	mfThis[0][3] = mfThis[1][3] = mfThis[2][3] =
	mfThis[3][0] = mfThis[3][1] = mfThis[3][2] = 
	mfThis[2][0] = mfThis[0][2] = mfThis[1][0] = mfThis[0][1] = 0 ;

	mfThis[0][0] = mfThis[3][3] = 1 ;

	mfThis[2][1] = -sine ;
	mfThis[1][2] = +sine ; 

	mfThis[1][1] = mfThis[2][2] = cosine ;
}


void CMtxF__RotateY(CMtxF mfThis, float Theta)
{
	float	sine ;
	float	cosine ;

	sine = sin(Theta) ;
	cosine = cos(Theta) ;

	mfThis[0][3] = mfThis[1][3] = mfThis[2][3] =
	mfThis[3][0] = mfThis[3][1] = mfThis[3][2] = 
	mfThis[2][1] = mfThis[1][2] = mfThis[1][0] = mfThis[0][1] = 0 ;

	mfThis[1][1] = mfThis[3][3] = 1 ;
	mfThis[2][0] = sine ;
	mfThis[0][2] = -sine ;
	mfThis[0][0] = mfThis[2][2] = cosine ;
}

void CMtxF__RotateZ(CMtxF mfThis, float Theta)
{
	float	sine ;
	float	cosine ;

	sine = sin(Theta) ;
	cosine = cos(Theta) ;

	mfThis[0][3] = mfThis[1][3] = mfThis[2][3] =
	mfThis[3][0] = mfThis[3][1] = mfThis[3][2] = 
	mfThis[2][1] = mfThis[1][2] = mfThis[2][0] = mfThis[0][2] = 0 ;
	mfThis[3][3] = mfThis[2][2] = 1 ;

	mfThis[0][0] = mfThis[1][1] = cosine ;
	mfThis[1][0] = -sine ;
	mfThis[0][1] = sine ;
}



void CMtxF__PreMultRotateX(CMtxF mfThis, FLOAT RotX)
{
	float	SinRotX = sin(RotX), CosRotX = cos(RotX) ;
	float	a ;

	a = mfThis[1][0] ;
	mfThis[1][0] = (CosRotX * a) + (SinRotX * mfThis[2][0]) ;
	mfThis[2][0] = (-SinRotX * a) + (CosRotX * mfThis[2][0]) ;

	a = mfThis[1][1] ;
	mfThis[1][1] = (CosRotX * a) + (SinRotX * mfThis[2][1]) ;
	mfThis[2][1] = (-SinRotX * a) + (CosRotX * mfThis[2][1]) ;

	a = mfThis[1][2] ;
	mfThis[1][2] = (CosRotX * a) + (SinRotX * mfThis[2][2]) ;
	mfThis[2][2] = (-SinRotX * a) + (CosRotX * mfThis[2][2]) ;

	// Total Adds 6, Total Multiplies 12 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PostMultRotateX(CMtxF mfThis, FLOAT RotX)
{
	float	SinRotX = sin(RotX), CosRotX = cos(RotX) ;
	float	a ;

	a = mfThis[0][1] ;
	mfThis[0][1] = (a * CosRotX) + (mfThis[0][2] * -SinRotX) ;
	mfThis[0][2] = (a * SinRotX) + (mfThis[0][2] * CosRotX) ;

	a = mfThis[1][1] ;
	mfThis[1][1] = (a * CosRotX) + (mfThis[1][2] * -SinRotX) ;
	mfThis[1][2] = (a * SinRotX) + (mfThis[1][2] * CosRotX) ;

	a = mfThis[2][1] ;
	mfThis[2][1] = (a * CosRotX) + (mfThis[2][2] * -SinRotX) ;
	mfThis[2][2] = (a * SinRotX) + (mfThis[2][2] * CosRotX) ;

	a = mfThis[3][1] ;
	mfThis[3][1] = (a * CosRotX) + (mfThis[3][2] * -SinRotX) ;
	mfThis[3][2] = (a * SinRotX) + (mfThis[3][2] * CosRotX) ;

	// Total Adds 8, Total Multiplies 16 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PreMultRotateY(CMtxF mfThis, FLOAT RotY)
{
	float	SinRotY = sin(RotY), CosRotY = cos(RotY) ;
	float	a ;

	a = mfThis[0][0] ;
	mfThis[0][0] = (CosRotY * a) + (-SinRotY * mfThis[2][0]) ;
	mfThis[2][0] = (SinRotY * a) + (CosRotY * mfThis[2][0]) ;

	a = mfThis[0][1] ;
	mfThis[0][1] = (CosRotY * a) + (-SinRotY * mfThis[2][1]) ;
	mfThis[2][1] = (SinRotY * a) + (CosRotY * mfThis[2][1]) ;

	a = mfThis[0][2] ;
	mfThis[0][2] = (CosRotY * a) + (-SinRotY * mfThis[2][2]) ;
	mfThis[2][2] = (SinRotY * a) + (CosRotY * mfThis[2][2]) ;

	// Total Adds 6, Total Multiplies 12 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PostMultRotateY(CMtxF mfThis, FLOAT RotY)
{
	float	SinRotY = sin(RotY), CosRotY = cos(RotY) ;
	float	a ;

	a = mfThis[0][0] ;
	mfThis[0][0] = (a * CosRotY) + (mfThis[0][2] * SinRotY) ;
	mfThis[0][2] = (a * -SinRotY) + (mfThis[0][2] * CosRotY) ;

	a = mfThis[1][0] ;
	mfThis[1][0] = (a * CosRotY) + (mfThis[1][2] * SinRotY) ;
	mfThis[1][2] = (a * -SinRotY) + (mfThis[1][2] * CosRotY) ;

	a = mfThis[2][0] ;
	mfThis[2][0] = (a * CosRotY) + (mfThis[2][2] * SinRotY) ;
	mfThis[2][2] = (a * -SinRotY) + (mfThis[2][2] * CosRotY) ;

	a = mfThis[3][0] ;
	mfThis[3][0] = (a * CosRotY) + (mfThis[3][2] * SinRotY) ;
	mfThis[3][2] = (a * -SinRotY) + (mfThis[3][2] * CosRotY) ;

	// Total Adds 8, Total Multiplies 16 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PreMultRotateZ(CMtxF mfThis, FLOAT RotZ)
{
	float	SinRotZ = sin(RotZ), CosRotZ = cos(RotZ) ;
	float	a ;

	a = mfThis[0][0] ;
	mfThis[0][0] = (CosRotZ * a) + (SinRotZ * mfThis[1][0]) ;
	mfThis[1][0] = (-SinRotZ * a) + (CosRotZ * mfThis[1][0]) ;

	a = mfThis[0][1] ;
	mfThis[0][1] = (CosRotZ * a) + (SinRotZ * mfThis[1][1]) ;
	mfThis[1][1] = (-SinRotZ * a) + (CosRotZ * mfThis[1][1]) ;

	a = mfThis[0][2] ;
	mfThis[0][2] = (CosRotZ * a) + (SinRotZ * mfThis[1][2]) ;
	mfThis[1][2] = (-SinRotZ * a) + (CosRotZ * mfThis[1][2]) ;

	// Total Adds 6, Total Multiplies 12 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PostMultRotateZ(CMtxF mfThis, FLOAT RotZ)
{
	float	SinRotZ = sin(RotZ), CosRotZ = cos(RotZ) ;
	float	a ;

	a = mfThis[0][0] ;
	mfThis[0][0] = (a * CosRotZ) + (mfThis[0][1] * -SinRotZ) ;
	mfThis[0][1] = (a * SinRotZ) + (mfThis[0][1] * CosRotZ) ;

	a = mfThis[1][0] ;
	mfThis[1][0] = (a * CosRotZ) + (mfThis[1][1] * -SinRotZ) ;
	mfThis[1][1] = (a * SinRotZ) + (mfThis[1][1] * CosRotZ) ;

	a = mfThis[2][0] ;
	mfThis[2][0] = (a * CosRotZ) + (mfThis[2][1] * -SinRotZ) ;
	mfThis[2][1] = (a * SinRotZ) + (mfThis[2][1] * CosRotZ) ;

	a = mfThis[3][0] ;
	mfThis[3][0] = (a * CosRotZ) + (mfThis[3][1] * -SinRotZ) ;
	mfThis[3][1] = (a * SinRotZ) + (mfThis[3][1] * CosRotZ) ;

	// Total Adds 8, Total Multiplies 16 (Assumes column 4 = {0,0,0,1})
}

#define	FLOAT_SWAP(a,b)	\
	t = a ;                 \
	a = b ;                 \
	b = t ;


void CMtxF__PreMult3DSToU64(CMtxF mfThis)
{
	float	t ;

	FLOAT_SWAP(mfThis[1][0], mfThis[2][0]) ;
	FLOAT_SWAP(mfThis[1][1], mfThis[2][1]) ;
	FLOAT_SWAP(mfThis[1][2], mfThis[2][2]) ;

	// Total Adds 0, Total Multiplies 0 (Assumes column 4 = {0,0,0,1})
}

void CMtxF__CopyPreMult3DSToU64(CMtxF mfThis, CMtxF mfSource)
{
	mfThis[0][0] = mfSource[0][0] ;
	mfThis[0][1] = mfSource[0][1] ;
	mfThis[0][2] = mfSource[0][2] ;

	mfThis[1][0] = mfSource[2][0] ;
	mfThis[1][1] = mfSource[2][1] ;
	mfThis[1][2] = mfSource[2][2] ; 

	mfThis[2][0] = mfSource[1][0] ;
	mfThis[2][1] = mfSource[1][1] ;
	mfThis[2][2] = mfSource[1][2] ;

	mfThis[3][0] = mfSource[3][0] ;
	mfThis[3][1] = mfSource[3][1] ;
	mfThis[3][2] = mfSource[3][2] ;

	MATRIX_SET_LAST_COLUMN
	// Total Adds 0, Total Multiplies 0 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__PostMult3DSToU64(CMtxF mfThis)
{
	float	t ;

	FLOAT_SWAP(mfThis[0][1], mfThis[0][2]) ;
	FLOAT_SWAP(mfThis[1][1], mfThis[1][2]) ;
	FLOAT_SWAP(mfThis[2][1], mfThis[2][2]) ;
	FLOAT_SWAP(mfThis[3][1], mfThis[3][2]) ;

	// Total Adds 0, Total Multiplies 0 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__CopyPostMult3DSToU64(CMtxF mfThis, CMtxF mfSource)
{
	mfThis[0][0] = mfSource[0][0] ;
	mfThis[0][1] = mfSource[0][2] ;
	mfThis[0][2] = mfSource[0][1] ;

	mfThis[1][0] = mfSource[1][0] ;
	mfThis[1][1] = mfSource[1][2] ;
	mfThis[1][2] = mfSource[1][1] ;

	mfThis[2][0] = mfSource[2][0] ;
	mfThis[2][1] = mfSource[2][2] ;
	mfThis[2][2] = mfSource[2][1] ;

	mfThis[3][0] = mfSource[3][0] ;
	mfThis[3][1] = mfSource[3][2] ;
	mfThis[3][2] = mfSource[3][1] ;

	MATRIX_SET_LAST_COLUMN

	// Total Adds 0, Total Multiplies 0 (Assumes column 4 = {0,0,0,1})
}


void CMtxF__ToMtxPostMultTranslate(CMtxF mfThis, Mtx *m, FLOAT Tx, FLOAT Ty, FLOAT Tz)
{
	INT32	e1,e2 ;
	INT32	*ai,*af ;

	ai=(INT32 *)&m->m[0][0] ;
	af=(INT32 *)&m->m[2][0] ;

	e1=FTOFIX32(mfThis[0][0]) ;
	e2=FTOFIX32(mfThis[0][1]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[0][2]) ;
	e2=FTOFIX32(mfThis[0][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;

	e1=FTOFIX32(mfThis[1][0]) ;
	e2=FTOFIX32(mfThis[1][1]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[1][2]) ;
	e2=FTOFIX32(mfThis[1][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;

	e1=FTOFIX32(mfThis[2][0]) ;
	e2=FTOFIX32(mfThis[2][1]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[2][2]) ;
	e2=FTOFIX32(mfThis[2][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;

	e1=FTOFIX32(mfThis[3][0]) + FTOFIX32(Tx) ;
	e2=FTOFIX32(mfThis[3][1]) + FTOFIX32(Ty) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[3][2]) + FTOFIX32(Tz) ;
	e2=FTOFIX32(mfThis[3][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
}



// This function is an unrolled version of "guMtxF2L((mfThis), &(mFixed))"
void CMtxF__ToMtxFast(CMtxF mfThis, Mtx *m)
{
	INT32	e1,e2 ;
	INT32	*ai,*af ;

	ai=(INT32 *)&m->m[0][0] ;
	af=(INT32 *)&m->m[2][0] ;

	e1=FTOFIX32(mfThis[0][0]) ;
	e2=FTOFIX32(mfThis[0][1]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[0][2]) ;
	e2=FTOFIX32(mfThis[0][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;

	e1=FTOFIX32(mfThis[1][0]) ;
	e2=FTOFIX32(mfThis[1][1]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[1][2]) ;
	e2=FTOFIX32(mfThis[1][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;

	e1=FTOFIX32(mfThis[2][0]) ;
	e2=FTOFIX32(mfThis[2][1]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[2][2]) ;
	e2=FTOFIX32(mfThis[2][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;

	e1=FTOFIX32(mfThis[3][0]) ;
	e2=FTOFIX32(mfThis[3][1]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
	e1=FTOFIX32(mfThis[3][2]) ;
	e2=FTOFIX32(mfThis[3][3]) ;
	*(ai++) = ( e1 & 0xffff0000 ) | ((e2 >> 16)&0xffff) ;
	*(af++) = ((e1 << 16) & 0xffff0000) | (e2 & 0xffff) ;
}










